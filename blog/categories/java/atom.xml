<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | regenthypo's Blog]]></title>
  <link href="http://www.regenthypo.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.regenthypo.com/"/>
  <updated>2016-04-17T17:29:35+08:00</updated>
  <id>http://www.regenthypo.com/</id>
  <author>
    <name><![CDATA[regenthypo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CopyOnWriteArrayList类源码解析]]></title>
    <link href="http://www.regenthypo.com/blog/2016/04/17/copyonwritearraylist-analyse/"/>
    <updated>2016-04-17T15:58:24+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/04/17/copyonwritearraylist-analyse</id>
    <content type="html"><![CDATA[<p>public class CopyOnWriteArrayList<E> extends Object implements List<E>, RandomAccess, Cloneable, SerializableArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p>

<p>这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。“快照”风格的迭代器方法在创建迭代器时使用了对数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。</p>

<p>允许使用所有元素，包括 null。</p>

<p>内存一致性效果：当存在其他并发 collection 时，将对象放入 CopyOnWriteArrayList 之前的线程中的操作 happen-before 随后通过另一线程从 CopyOnWriteArrayList 中访问或移除该元素的操作。</p>

<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>

<p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>

<p>使用场景：读取频繁，写较少。 理由：底层的安全性 本质上是依赖于线程读取的数据副本来实现的。因此每次写都是要复制底层数组数据的，如果写频繁势必会造成大量的性能消耗。</p>

<p>CopyOnWriteArrayList要修改时，都是将旧数组先复制到新数组中，再在新数组上修改，修改完了，再将旧数组的引用指向新数组.
不管是set方法，还是add方法,remove方法都是这样的.<br>
```java
   private static final long serialVersionUID = 8673264195747942595L;</p>

<pre><code>/** The lock protecting all mutators */
transient final ReentrantLock lock = new ReentrantLock();//显示锁

/** The array, accessed only via getArray/setArray. */
private volatile transient Object[] array;

/**
 * Gets the array.  Non-private so as to also be accessible
 * from CopyOnWriteArraySet class.
 * getArray()返回的引用是事实上不可变的，如果没有这个保证，那么这个操作不可能是线程安全
 */
final Object[] getArray() 
{
    return array;//返回当前数组的引用
}

final void setArray(Object[] a)
{
    array = a;//将旧数组引用指向新数组
}

/**
 * 如果新建CopyOnWriteArrayList对象时没有指定大小，默认是空的
 */
public CopyOnWriteArrayList() {
    setArray(new Object[0]);
}

/**
 * Creates a list containing the elements of the specified
 * collection, in the order they are returned by the collection's
 * iterator.
 *
 * @param c the collection of initially held elements
 * @throws NullPointerException if the specified collection is null
 */
public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) {
    Object[] elements = c.toArray();
    // c.toArray might (incorrectly) not return Object[] (see 6260652)
    if (elements.getClass() != Object[].class)
        elements = Arrays.copyOf(elements, elements.length, Object[].class);
    setArray(elements);
}

/**
 * Creates a list holding a copy of the given array.
 *
 * @param toCopyIn the array (a copy of this array is used as the
 *        internal array)
 * @throws NullPointerException if the specified array is null
 */
public CopyOnWriteArrayList(E[] toCopyIn) {
    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
}


public int size() {
    return getArray().length;
}

public boolean isEmpty() {
    return size() == 0;
}
</code></pre>

<pre><code></code></pre>

<pre><code>public E set(int index, E element) 
{
    final ReentrantLock lock = this.lock;//使用显示锁同步
    lock.lock();
    try 
    {
        Object[] elements = getArray();//当前CopyOnWriteArrayList引用

        E oldValue = get(elements, index);//得到当前index位置上的元素引用

        if (oldValue != element) 
        {
            int len = elements.length;

            //复制当前数组到一个新数组
            Object[] newElements = Arrays.copyOf(elements, len);

            //修改新数组，老数组并没有改变
            newElements[index] = element;

            //将旧数组引用指向新数组
            setArray(newElements);
        } 
        else 
        {
            // Not quite a no-op; ensures volatile write semantics
            setArray(elements);
        }
        return oldValue;
    } 
    finally
    {
        lock.unlock();//显示锁要手动释放.
    }
}
</code></pre>

<pre><code></code></pre>

<pre><code>public boolean add(E e)
{
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();

        int len = elements.length;

        Object[] newElements = Arrays.copyOf(elements, len + 1);

        newElements[len] = e;

        //将旧数组引用指向新数组
        setArray(newElements);

        return true;
    } 
    finally 
    {
        lock.unlock();
    }
}
</code></pre>

<pre><code></code></pre>

<pre><code>public E remove(int index) 
{
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre>

<pre><code>
读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList.
</code></pre>

<pre><code>public E get(int index) 
{
    //如果读的时候正好有线程在改变数组也没关系，在数组没有修改完的情况下，getArray()返回的是旧
    //数组的引用.所有本次读到的还是旧数组的值.
    return get(getArray(), index);
}
</code></pre>

<pre><code>
CopyOnWriteArrayList的迭代器&lt;br&gt;
</code></pre>

<p>   public Iterator<E> iterator() {
        return new COWIterator<E>(getArray(), 0);
    }</p>

<pre><code>/**
 * {@inheritDoc}
 *
 * &lt;p&gt;The returned iterator provides a snapshot of the state of the list
 * when the iterator was constructed. No synchronization is needed while
 * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the
 * &lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt; or &lt;tt&gt;add&lt;/tt&gt; methods.
 */
public ListIterator&lt;E&gt; listIterator() {
    return new COWIterator&lt;E&gt;(getArray(), 0);
}

/**
 * {@inheritDoc}
 *
 * &lt;p&gt;The returned iterator provides a snapshot of the state of the list
 * when the iterator was constructed. No synchronization is needed while
 * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the
 * &lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt; or &lt;tt&gt;add&lt;/tt&gt; methods.
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public ListIterator&lt;E&gt; listIterator(final int index) {
    Object[] elements = getArray();
    int len = elements.length;
    if (index&lt;0 || index&gt;len)
        throw new IndexOutOfBoundsException("Index: "+index);

    return new COWIterator&lt;E&gt;(elements, index);
}

private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {
    /** Snapshot of the array */
    private final Object[] snapshot;
    /** Index of element to be returned by subsequent call to next.  */
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }

    public boolean hasNext() {
        return cursor &lt; snapshot.length;
    }

    public boolean hasPrevious() {
        return cursor &gt; 0;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        if (! hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    }

    @SuppressWarnings("unchecked")
    public E previous() {
        if (! hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }

    /**
     * Not supported. Always throws UnsupportedOperationException.
     * @throws UnsupportedOperationException always; &lt;tt&gt;remove&lt;/tt&gt;
     *         is not supported by this iterator.
     */
    public void remove() {
        throw new UnsupportedOperationException();
    }

    /**
     * Not supported. Always throws UnsupportedOperationException.
     * @throws UnsupportedOperationException always; &lt;tt&gt;set&lt;/tt&gt;
     *         is not supported by this iterator.
     */
    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    /**
     * Not supported. Always throws UnsupportedOperationException.
     * @throws UnsupportedOperationException always; &lt;tt&gt;add&lt;/tt&gt;
     *         is not supported by this iterator.
     */
    public void add(E e) {
        throw new UnsupportedOperationException();
    }
}
</code></pre>

<p>```</p>

<p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>

<p>　　内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>

<p>　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>

<p>　　数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java运行时数据区]]></title>
    <link href="http://www.regenthypo.com/blog/2016/04/12/java-runtime-data-memory/"/>
    <updated>2016-04-12T21:00:34+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/04/12/java-runtime-data-memory</id>
    <content type="html"><![CDATA[<p><img src="/images/jrd_1.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java异常]]></title>
    <link href="http://www.regenthypo.com/blog/2016/04/12/java-exception/"/>
    <updated>2016-04-12T19:49:37+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/04/12/java-exception</id>
    <content type="html"><![CDATA[<p><img src="/images/je1.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类型生命周期]]></title>
    <link href="http://www.regenthypo.com/blog/2016/04/12/java-class-lifecycle/"/>
    <updated>2016-04-12T16:26:50+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/04/12/java-class-lifecycle</id>
    <content type="html"><![CDATA[<p>Java虚拟机通过装载、连接和初始化一个Java类型，使该类型可以被正在运行的Java程序所使用。其中，
装载就是把二进制形式的Java类型读入Java虚拟机中；<br>
连接就是把这种已经读入虚拟机的二进制形式的类型数据合并到虚拟机的运行时状态中;<br></p>

<p>连接阶段分为三个子步骤——验证、准备和解析<br>
验证步骤确保了Java类型数据格式正确并且适于Java虚拟机使用;<br>
准备步骤则负责为该类型分配它所需的内存，比如为它的类变量分配内存;<br>
解析步骤则负责把常量池中的符号引用转换为直接引用;<br></p>

<p>初始化阶段，都将为类变量赋以适当的初始值.<br></p>

<p><img src="/images/jcc1.jpg"></p>

<h2>java类的初始化 <br></h2>

<p>Java虚拟机规范严格定义了类的初始化时机<br>
所有的Java虚拟机实现必须在每个类或接口首次主动使用时初始化，以下六种情形符合主动使用的要求:<br>
<img src="/images/jcc2.jpg"></p>

<h2>Java类的装载 <br></h2>

<p><img src="/images/jcc3.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Puzzlers读书笔记]]></title>
    <link href="http://www.regenthypo.com/blog/2016/03/24/java-puzzlers/"/>
    <updated>2016-03-24T21:11:35+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/03/24/java-puzzlers</id>
    <content type="html"><![CDATA[<h2>解惑3：长整形相除<br></h2>

<p><img src="/images/jp3.jpg"></p>
]]></content>
  </entry>
  
</feed>
