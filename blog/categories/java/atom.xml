<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | regenthypo's Blog]]></title>
  <link href="http://www.regenthypo.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.regenthypo.com/"/>
  <updated>2016-03-30T21:11:15+08:00</updated>
  <id>http://www.regenthypo.com/</id>
  <author>
    <name><![CDATA[regenthypo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Puzzlers读书笔记]]></title>
    <link href="http://www.regenthypo.com/blog/2016/03/24/java-puzzlers/"/>
    <updated>2016-03-24T21:11:35+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/03/24/java-puzzlers</id>
    <content type="html"><![CDATA[<h2>解惑3：长整形相除<br></h2>

<p><img src="/images/jp3.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java单例模式深入解析]]></title>
    <link href="http://www.regenthypo.com/blog/2016/03/24/java-singleton/"/>
    <updated>2016-03-24T14:23:33+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/03/24/java-singleton</id>
    <content type="html"><![CDATA[<p>作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类.</p>

<p>单例模式有以下特点:<br>
1. 单例类只能有一个实例<br>
2. 单例类必须自己创建自己的唯一的实例<br>
3. 单例类必须给所有其他对象提供这一个实例.<br></p>

<h3>最简单的单例类</h3>

<pre><code class="java">package DP1_4.Singleton;

public class EagerSingleton
{
    private static final EagerSingleton instance = new EagerSingleton();

    //私有构造函数
    private EagerSingleton()
    {
    }

    //静态工厂方法
    public static EagerSingleton getInstance()
    {
        return instance;
    }
}
</code></pre>

<p>在这个类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用。此时，单例类的唯一实例就别创建出来了.<br>
Java语言中单例类的一个重要特点是类的构造函数是私有的，从而避免外界利用构造函数直接创建出任意多的实例。<br>
值得注意的是，由于构造函数是私有的，因此该类不能被继承.<br>
<font color=#FF0000>注意类的静态变量当且仅当类初次加载时会被初始化，所以EagerSingleton类中的instance静态变量只会在类加载时初始化一次，
即只会产生一个对象,而且这个对象一定会产生出来.</font><br></p>

<h3>lazy loaded单例类</h3>

<pre><code class="java">package DP1_4.Singleton;

public class LazySingleton
{
    private static LazySingleton instance= null;

    //私有构造方法
    private LazySingleton()
    {
    }

    //静态工厂方法
    public static LazySingleton getInstance()
    {
        if(instance == null)
        {
            instance = new LazySingleton();
        }
        return instance;
    }
}
</code></pre>

<p>代码的变化有两处——首先，把instance初始化为null，直到第一次使用的时候通过判断是否为null来创建对象。因为创建过程不在声明处，所以那个final的修饰必须去掉。<br>
要使用LazySingleton，调用getInstance()方法。第一次的时候发现instance是null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个instance是static的，所以已经不是null了，因此不会再创建对象，直接将其返回。<br>
这个过程就成为lazy loaded，也就是迟加载——直到使用的时候才进行加载.<br></p>

<h3>同步的单例类</h3>

<p>线程A希望使用LazySingleton，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换，线程B开始执行，它要使用LazySingleton，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个LazySingleton的对象——单例失败.</p>

<pre><code class="java">package DP1_4.Singleton;

public class SynchronizedSingleton
{
    private static SynchronizedSingleton instance= null;

    //私有构造方法
    private SynchronizedSingleton()
    {
    }

    //加synchronized关键字的静态工厂方法
    public synchronized static SynchronizedSingleton getInstance()
    {
        if(instance == null)
        {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
}
</code></pre>

<p>给getInstance方法加上synchronzied方法，一个线程必须等待另一个线程创建完后才能调用该方法，这时单例类的对象已经产生，再判断instance == null就会失败，保证了单例的唯一性.<br></p>

<h3>同步单例类性能提升</h3>

<p>参考资料:<br>
1. <a href="http://devbean.blog.51cto.com/448512/203501">http://devbean.blog.51cto.com/448512/203501</a><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java String对象的内存机制]]></title>
    <link href="http://www.regenthypo.com/blog/2016/03/24/java-string/"/>
    <updated>2016-03-24T13:59:12+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/03/24/java-string</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comparator接口和Comparable接口]]></title>
    <link href="http://www.regenthypo.com/blog/2016/03/21/comparator-and-comparable/"/>
    <updated>2016-03-21T19:22:29+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/03/21/comparator-and-comparable</id>
    <content type="html"><![CDATA[<p>当需要排序的集合或数组不是单纯的数字型时，通常可以使用Comparator或Comparable接口，以简单的方式实现对象排序或自定义排序.<br></p>

<p>Comparator接口源代码<br></p>

<pre><code class="java">
package java.util;

public interface Comparator&lt;T&gt;
{
    int compare(T o1, T o2);

    boolean equals(Object obj);
}
</code></pre>

<p>Comparator接口:<br>
强行对某个对象collection进行整体排序的比较函数.可以将Comparator传递给sort方法(如Collections.sort或Arrays.sort)，从而允许在排序顺序上实现精确控制.还可以使用Comparator来控制某些数据结构(如有序set或有序映射)的顺序,或者为那些没有自然顺序地对象collection提供排序.<br>
Comparator接口中有两个未实现的方法，但是不一定要实现equals方法，除非有特殊的性能需要，因为无论何时创建一个类，都是间接继承自Object,而Object带有equals方法。所以只需要默认的Object的equals方法就可以满足接口的要求了.<br>
<font color=#FF0000>基本类型无法使用Comparator进行排序.</font><br></p>

<p>Collections类中有两个重载的sort方法:<br>
<img src="/images/cc5.jpg">
<img src="/images/cc2.jpg"></p>

<p><img src="/images/cc6.jpg">
<img src="/images/cc3.jpg"></p>

<p><font color=#FF0000>其实Collections类中的两个重载sort方法在源代码实现上是调用了Arrays类中的sort方法(见上两图红框中调用).</font><br></p>

<p>Arrays类中有很多重载的sort方法:<br>
分为两大类，一类是对基本数据类型的数组的排序方法，采用DualPivotQuicksort(多路快排)进行排序;<br>
另一类是引用类型的数组的排序排序方法，采用MergeSort(稳定归并排序)来进行排序;<br></p>

<p>Arrays中sort方法可以传Comparator参数的两个方法：
<img src="/images/cc9.jpg">
<img src="/images/cc7.jpg"></p>

<p><img src="/images/cc10.jpg">
<img src="/images/cc8.jpg"></p>

<p>Comparator接口使用实例：<br>
<figure class='code'><figcaption><span>hashmapSort.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">hypo</span><span class="o">.</span><span class="na">collection</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//HashMap根据值排序</span>
</span><span class='line'><span class="c1">//通过把HashMap中的所有Entry存入一个List,然后调用collection的sort进行排序操作.</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">hashmapSort</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">HashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Character</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Character</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;();&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">&#39;b&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span><span class='line'>    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">&#39;c&#39;</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</span><span class='line'>    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span><span class='line'>    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">&#39;e&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span><span class='line'>    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">&#39;f&#39;</span><span class="o">,</span><span class="mi">4</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//Map.Entry&amp;lt;K,V&amp;gt;是接口，其方法有getKey(),getValue()等.</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Character</span><span class="o">,</span><span class="n">Integer</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">info</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Character</span><span class="o">,</span><span class="n">Integer</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">hm</span><span class="o">.</span><span class="na">entrySet</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//排序前</span>
</span><span class='line'>    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">info</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">;</span><span class="n">i</span><span class="o">++)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">info</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//排序</span>
</span><span class='line'>    <span class="c1">//通过把HashMap中的所有Entry存入一个List,然后调用collection的sort进行排序操作.</span>
</span><span class='line'>    <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">info</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Character</span><span class="o">,</span><span class="n">Integer</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;()</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">o1</span><span class="o">,</span>
</span><span class='line'>                <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">o2</span><span class="o">)</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="c1">// TODO Auto-generated method stub</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;===============================&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">//排序后</span>
</span><span class='line'>    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">info</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">info</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
hashmapSort.java运行结果：<br>
<img src="/images/cc4.jpg"></p>

<p>可以看程序中Collections.sort调用的关系:<br>
<img src="/images/cc1.jpg"></p>

<p>Comparable接口源代码<br></p>

<pre><code class="java ">
package java.lang;
import java.util.*;

public interface Comparable&lt;T&gt; 
{
    public int compareTo(T o);
}
</code></pre>

<p>Comparable接口：此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。实现此接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort）进行
<font color=#FF0000>自动排序</font>
实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。<br>
java.lang.Comparable接口，使你的类具有“天生”的比较能力.此接口很简单，只有compareTo()一个方法.此方法接受另一个Object为参数，
如果当前对象小于参数则返回负值，如果相等则返回零，如果当前对象大于参数则返回正值.</p>

<p>Comparable接口使用实例:<br></p>

<pre><code class="java comparableTest.java">
package hypo.collection;

import java.util.Arrays;

class Student implements Comparable&lt;Student&gt;
{
    private String name;
    private int age;
    private float score;

    public Student(String name , int age ,float score)
    {
        // TODO Auto-generated constructor stub
        this.name = name;
        this.age = age;
        this.score = score;
    }

    @Override
    public String toString()
    {
        // TODO Auto-generated method stub
        return name + "\t" + age +"\t" + score;
    }

    @Override
    public int compareTo(Student o)
    {
        // TODO Auto-generated method stub
        if(this.score &gt; o.score)
        {
            return -1;
        }
        else if(this.score &lt; o.score)
        {
            return 1;
        }
        else
        {
            if(this.age &gt; o.age)
            {
                return 1;
            }
            else if(this.age &lt; o.age)
            {
                return -1;
            }
            else
            {
                return 0;
            }
        }
    }
}


public class comparableTest
{

    public static void main(String[] args)
    {
        // TODO Auto-generated method stub
        Student student[] = {
                new Student("Lily", 20 , 90.0f),
                new Student("Suny" ,22 , 91.0f),
                new Student("Sady" ,23 , 90.0f),
                new Student("Tomy" ,25 , 88.0f),
                new Student("Jimy" ,25 , 99.0f)
        };

        System.out.println("===排序前===");
        for(Student s : student)
        {
            System.out.println(s);
        }

        Arrays.sort(student);

        System.out.println("===排序后===");
        for(Student s : student)
        {
            System.out.println(s);
        }
    }

}
</code></pre>

<p>comparableTest.java运行结果：<br>
<img src="/images/cc11.jpg"></p>

<p>总结:<br>
两种方法各有优劣, 用Comparable 简单, 只要实现Comparable 接口的对象直接就成为一个可以比较的对象,
但是需要修改源代码, 用Comparator 的好处是不需要修改源代码, 而是另外实现一个比较器, 当某个自定义
的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator 里面用户可以自
己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java集合]]></title>
    <link href="http://www.regenthypo.com/blog/2016/03/21/java-collection/"/>
    <updated>2016-03-21T19:07:56+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/03/21/java-collection</id>
    <content type="html"><![CDATA[<p>Java集合框架图<br>
<img src="/images/jc1.jpg"></p>
]]></content>
  </entry>
  
</feed>
