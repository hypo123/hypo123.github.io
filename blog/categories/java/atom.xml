<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | regenthypo's Blog]]></title>
  <link href="http://www.regenthypo.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.regenthypo.com/"/>
  <updated>2016-07-26T20:31:55+08:00</updated>
  <id>http://www.regenthypo.com/</id>
  <author>
    <name><![CDATA[regenthypo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LinkedHashMap源码分析]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/26/linkedhashmap/"/>
    <updated>2016-07-26T16:01:38+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/26/linkedhashmap</id>
    <content type="html"><![CDATA[<h2>定义</h2>

<pre><code class="java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre>

<p><font color=#FF0000><strong>LinkedHashMap继承了HashMap类，实现了Map接口.</strong></font><br></p>

<h2>LinkedHashMap类中变量</h2>

<pre><code class="java">//双向链表的表头结点
private transient Entry&lt;K,V&gt; header;

//默认false。如果是true则表示get()命中后,把当前元素放到链表最后
private final boolean accessOrder;
</code></pre>

<h2>LinkedHashMap底层结构</h2>

<p><img src="/images/linkedhashmap4.jpg"></p>

<p><img src="/images/linkedhashmap5.jpg"></p>

<h2>LinkedHashMap类的构造函数</h2>

<pre><code class="java">public LinkedHashMap(int initialCapacity, float loadFactor) 
{
    super(initialCapacity, loadFactor);
    accessOrder = false;
}
</code></pre>

<pre><code class="java">public LinkedHashMap(int initialCapacity) 
{
    super(initialCapacity);
    accessOrder = false;
}
</code></pre>

<pre><code class="java">public LinkedHashMap() 
{
    super();
    accessOrder = false;
}
</code></pre>

<p><font color=#0000CD><strong>构造一个带指定初始容量、加载因子和排序模式的空LinkedHashMap实例.</strong></font><br>
<code>java
public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
{
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
</code></p>

<p><font color=#0000CD><strong>LinkedHashMap中的构造函数都是调用了HashMap类中的构造函数.</strong></font><br>
<font color=#0000CD><strong>HashMap构造函数都调用了init方法进行初始化,在HashMap类中init方法是一个空方法,什么都不做.</strong></font><br>
<font color=#0000CD><strong>LinkedHashMap中对init方法进行了重写.</strong></font><br>
<code>java
void init()
{
    header = new Entry&lt;&gt;(-1, null, null, null);
    header.before = header.after = header;
}
</code></p>

<p><font color=#FF0000><strong>经过init函数初始化后,header结点的before和after都指向header结点自己.</strong></font><br>
<img src="/images/linkedhashmap1.jpg"></p>

<h2>LinkedHashMap的内部类-结点</h2>

<p><font color=#0000CD><strong>双向链表上的结点都是由Entry对象组成.</strong></font><br>
<font color=#0000CD><strong>LinkedHashMap类的内部类Entry继承了HashMap类的内部类Entry</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="c1">//结点的双向链属性</span>
</span><span class='line'>    <span class="n">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Entry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">next</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//双向链表中删除结点</span>
</span><span class='line'><span class="c1">//并不是从table的链表中删除结点</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">before</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="n">after</span><span class="o">;</span>
</span><span class='line'>    <span class="n">after</span><span class="o">.</span><span class="na">before</span> <span class="o">=</span> <span class="n">before</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//双向链表中,在给定结点existingEntry前插入结点</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">addBefore</span><span class="o">(</span><span class="n">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">existingEntry</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">after</span>  <span class="o">=</span> <span class="n">existingEntry</span><span class="o">;</span>
</span><span class='line'>    <span class="n">before</span> <span class="o">=</span> <span class="n">existingEntry</span><span class="o">.</span><span class="na">before</span><span class="o">;</span>
</span><span class='line'>    <span class="n">before</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
</span><span class='line'>    <span class="n">after</span><span class="o">.</span><span class="na">before</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//此方法提供LRU实现</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">recordAccess</span><span class="o">(</span><span class="n">HashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">m</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">LinkedHashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">lm</span> <span class="o">=</span> <span class="o">(</span><span class="n">LinkedHashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">m</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//如果当前LinkedHashMap的accessOrder为true</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">lm</span><span class="o">.</span><span class="na">accessOrder</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="c1">//Map结构修改次数加1</span>
</span><span class='line'>        <span class="n">lm</span><span class="o">.</span><span class="na">modCount</span><span class="o">++;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//从结点链表中移除当前结点</span>
</span><span class='line'>        <span class="n">remove</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//将当前结点添加到原头结点的前面</span>
</span><span class='line'>        <span class="n">addBefore</span><span class="o">(</span><span class="n">lm</span><span class="o">.</span><span class="na">header</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//重写了HashMap内部类Entry中的recordRemoval方法</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">recordRemoval</span><span class="o">(</span><span class="n">HashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">m</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">remove</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#FF0000><strong>因为Entry继承自HashMap类的内部类Entry,本来已有成员变量key,value,hash , next;</strong></font><br>
<font color=#FF0000><strong>特别是已有next指向单链表的下一个结点; 在LinkedHashMap类的内部类Entry中由添加了成员变量before和after.</strong></font><br>
<font color=#FF0000><strong>实际上Entry结点共有next,before和after来指向不同的结点.</strong></font><br>
<font color=#FF0000><strong>其中next指针来控制table数组中的单链表,连接起同一个桶的结点</strong></font><br>
<font color=#FF0000><strong>before和after指针来形成双向链表,来表示结点的访问顺序.</strong></font><br></p>

<h2>存储元素——put函数</h2>

<p><font color=#0000CD><strong>LinkedHashMap继承了HashMap的put函数，但是并没有重写put函数,而是重写put函数里调用的函数addEntry.</strong></font><br>
<font color=#0000CD><strong>所以调用LinkedHashMap的put函数会产生于HashMap的put函数不一样的效果.</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">void</span> <span class="nf">addEntry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bucketIndex</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">createEntry</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">bucketIndex</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">eldest</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="na">after</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//如果removeEldestEntry函数返回值为true,则从链表中移除eldest结点.</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">removeEldestEntry</span><span class="o">(</span><span class="n">eldest</span><span class="o">))</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">removeEntryForKey</span><span class="o">(</span><span class="n">eldest</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="c1">//如果size大于等于阈值,要对table数组进行扩容.</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="n">threshold</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">resize</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">font</span> <span class="n">color</span><span class="o">=</span><span class="err">#</span><span class="mi">0000</span><span class="n">CD</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;**</span><span class="n">addEntry函数是LinkedHashMap类中唯一用到removeEldestEntry函数的地方</span><span class="o">.</span><span class="na">即之后如果要重写removeEldestEntry函数</span><span class="err">，</span>
</span><span class='line'>    <span class="n">会在这里产生效果</span><span class="o">.**&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">font</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">br</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">font</span> <span class="n">color</span><span class="o">=</span><span class="err">#</span><span class="mi">0000</span><span class="n">CD</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;**</span><span class="n">LinkedHashMap重写了HashMap中的createEntry方法</span><span class="o">.**&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">font</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">br</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">font</span> <span class="n">color</span><span class="o">=</span><span class="err">#</span><span class="mi">0000</span><span class="n">CD</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;**</span><span class="n">新建结点</span><span class="o">**&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">font</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">br</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">createEntry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bucketIndex</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">HashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">old</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">];&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//hash值,键key , 值value , old结点作为新建结点的下一个结点</span>
</span><span class='line'><span class="n">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">old</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//设置当前结点的单链表属性</span>
</span><span class='line'><span class="c1">//将当前结点设置为单链表的头结点</span>
</span><span class='line'><span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//设置当前结点的双向链表属性</span>
</span><span class='line'><span class="n">e</span><span class="o">.</span><span class="na">addBefore</span><span class="o">(</span><span class="n">header</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">size</span><span class="o">++;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>  <br/>
<font color=#000000><strong>第一次执行e.addBefore(header)操作</strong></font><br>
<img src="/images/linkedhashmap2.jpg"></p>

<p><font color=#000000><strong>再继续执行c.addBefore(header)操作</strong></font><br>
<img src="/images/linkedhashmap3.jpg"></p>

<p><font color=#0000CD><strong>LinkedHashMap中的removeEldestEntry函数默认返回值为false,如果要返回true,可重写该方法.</strong></font><br>
<code>java
protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)
{
    return false;
}
</code></p>

<h2>读取元素——get函数</h2>

<p><font color=#0000CD><strong>LinkedHashMap重写了HashMap中的get方法.</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="c1">//getEntry为HashMap类中的方法,可根据键得到结点Entry对象</span>
</span><span class='line'>    <span class="n">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">getEntry</span><span class="o">(</span><span class="n">key</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//LRU处理</span>
</span><span class='line'><span class="n">e</span><span class="o">.</span><span class="na">recordAccess</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#000000><strong>LinkedHashMap中键key和值value都可以为null.</strong></font><br></p>

<p><font color=#000000><strong>LinkedHashMap类的内部类Entry的recordAccess方法.</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//此方法提供LRU实现</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">recordAccess</span><span class="o">(</span><span class="n">HashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">LinkedHashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">lm</span> <span class="o">=</span> <span class="o">(</span><span class="n">LinkedHashMap</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">m</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//如果当前LinkedHashMap的accessOrder为true</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">lm</span><span class="o">.</span><span class="na">accessOrder</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="c1">//Map结构修改次数加1</span>
</span><span class='line'>    <span class="n">lm</span><span class="o">.</span><span class="na">modCount</span><span class="o">++;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//从双向链表中移除当前结点</span>
</span><span class='line'>    <span class="n">remove</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//将当前结点插入到header结点后的第一个结点.</span>
</span><span class='line'>    <span class="n">addBefore</span><span class="o">(</span><span class="n">lm</span><span class="o">.</span><span class="na">header</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>删除元素——remove函数</h2>

<p><font color=#000000><strong>LinkedHashMap没有重写remove(Object key)方法,但重写了被remove调用的recordRemoval方法.</strong></font><br></p>

<pre><code class="java">void recordRemoval(HashMap&lt;K,V&gt; m) 
{
    remove();
}
</code></pre>

<pre><code class="java">private void remove() 
{
    before.after = after;
    after.before = before;
}
</code></pre>

<p><font color=#FF0000><strong>recordRemoval方法是因为LinkedHashMap中结点不仅有单链表的关系，还有双向链表的关系.</strong></font><br>
<font color=#FF0000><strong>所以LinkedHashMap中删除结点,不仅要处理该结点单链表中的指向关系,还要处理该结点在双向链表中的指向关系.</strong></font><br>
<font color=#FF0000><strong>而recordRemoval函数中调用remove函数就是处理该结点的双向链表关系.</strong></font><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ConcurrentHashMap源码分析]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/25/concurrenthashmap/"/>
    <updated>2016-07-25T17:01:58+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/25/concurrenthashmap</id>
    <content type="html"><![CDATA[<h2>定义</h2>

<pre><code class="java">public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;
        implements ConcurrentMap&lt;K, V&gt;, Serializable
</code></pre>

<p><font color=#FF0000><strong>ConcurrentHashMap继承了AbstractMap类，实现了ConcurrentMap接口.</strong></font><br></p>

<h2>ConcurrentHashMap类中变量</h2>

<pre><code class="java">    private static final long serialVersionUID = 7249069246763182397L;

    /* ---------------- 常量 -------------- */

    static final int DEFAULT_INITIAL_CAPACITY = 16;//默认的初始容量为16

    static final float DEFAULT_LOAD_FACTOR = 0.75f;//默认装载因子

    static final int DEFAULT_CONCURRENCY_LEVEL = 16;//默认分为16个段

    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//最大容量

    static final int MIN_SEGMENT_TABLE_CAPACITY = 2;//最小段数组大小

    static final int MAX_SEGMENTS = 1 &lt;&lt; 16; //最大段数

    //用于公用的size()函数和containsValue()函数
    static final int RETRIES_BEFORE_LOCK = 2;//加锁之前,可非同步的试两次

    /* ---------------- 成员变量 -------------- */

    final int segmentMask;//段掩码

    final int segmentShift;//段偏移量

    final Segment&lt;K,V&gt;[] segments;//段的数组

    transient Set&lt;K&gt; keySet;
    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
    transient Collection&lt;V&gt; values;
</code></pre>

<pre><code class="java">    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long SBASE;
    private static final int SSHIFT;
    private static final long TBASE;
    private static final int TSHIFT;

    static 
    {
        int ss, ts;

        try 
        {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class tc = HashEntry[].class;
            Class sc = Segment[].class;
            TBASE = UNSAFE.arrayBaseOffset(tc);
            SBASE = UNSAFE.arrayBaseOffset(sc);
            ts = UNSAFE.arrayIndexScale(tc);
            ss = UNSAFE.arrayIndexScale(sc);
        } 
        catch (Exception e) 
        {
            throw new Error(e);
        }
        if ((ss &amp; (ss-1)) != 0 || (ts &amp; (ts-1)) != 0)
        {
            throw new Error("data type scale not a power of two");
        }
        SSHIFT = 31 - Integer.numberOfLeadingZeros(ss);
        TSHIFT = 31 - Integer.numberOfLeadingZeros(ts);
    }
</code></pre>

<h2>ConcurrentHashMap底层结构</h2>

<p><font color=#0000CD><strong>Hashtable中锁定的单位是整个table数组.只要有一个线程已经锁定了Hashtable，别的线程只能等该线程操作完毕释放锁后，才能对Hashtable进行操作.</strong></font><br>
<img src="/images/concurrentHashMap1.jpg"></p>

<p><font color=#0000CD><strong>ConcurrentHashMap并不是讲每个方法都在同一个锁上进行同步并使得每次只能有一个线程访问容器，
    而是使用了一种粒度更细的加锁机制来实现更大程度的共享.</strong></font><br></p>

<p><font color=#0000CD><strong>ConcurrentHashMap锁定的单位是段.</strong></font><br>
<img src="/images/concurrentHashMap2.jpg"></p>

<p><font color=#FF0000><strong>基于以上分段锁技术,ConcurrentHashMap允许任意数量的读取线程并发地访问Map，执行读取操作的线程和执行写入操作的线程
    可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map。</strong></font><br></p>

<p><font color=#FF0000><strong>ConcurrentHashMap在并发环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能.</strong></font><br></p>

<p><img src="/images/concurrentHashMap3.jpg"></p>

<h2>ConcurrentHashMap类的构造函数</h2>

<pre><code class="java">    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) 
    {
        //判断参数是否合法
        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
            throw new IllegalArgumentException();

        if (concurrencyLevel &gt; MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;

        int sshift = 0;//ssize左移次数
        int ssize = 1;

        while (ssize &lt; concurrencyLevel) 
        {
            ++sshift;
            ssize &lt;&lt;= 1;
        }

        this.segmentShift = 32 - sshift;//段偏移

        this.segmentMask = ssize - 1;//段掩码

        if (initialCapacity &gt; MAXIMUM_CAPACITY)
        {
            initialCapacity = MAXIMUM_CAPACITY;
        }

        int c = initialCapacity / ssize;

        if (c * ssize &lt; initialCapacity)
        {
            ++c;
        }

        int cap = MIN_SEGMENT_TABLE_CAPACITY;

        while (cap &lt; c)
        {
            cap &lt;&lt;= 1;
        }

        Segment&lt;K,V&gt; s0 =
            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);

        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];

        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]

        this.segments = ss;
    }
</code></pre>

<h2>ConcurrentHashMap的内部类-结点</h2>

<p><font color=#0000CD><strong>链表上的结点都是由HashEntry对象组成.</strong></font><br>
<font color=#0000CD><strong>ConcurrentHashMap类的内部类HashEntry</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span><span class="c1">//hash值 final修饰</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span> <span class="c1">//键       final修饰</span>
</span><span class='line'>        <span class="kd">volatile</span> <span class="n">V</span> <span class="n">value</span><span class="o">;</span> <span class="c1">//值</span>
</span><span class='line'>        <span class="kd">volatile</span> <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span> <span class="c1">//下一个结点&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="nf">HashEntry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">next</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setNext</span><span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">n</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putOrderedObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nextOffset</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Unsafe mechanics</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">nextOffset</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">static</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
</span><span class='line'>            <span class="n">Class</span> <span class="n">k</span> <span class="o">=</span> <span class="n">HashEntry</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</span><span class='line'>            <span class="n">nextOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
</span><span class='line'>                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;next&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#0000CD><strong>HashEntry的成员变量hash和key都是final修饰;</strong></font><br>
<font color=#0000CD><strong>HashEntry的成员变量value和next都是volatile修饰;</strong></font><br></p>

<h2>计算添加元素的位置</h2>

<p><font color=#0000CD><strong> </strong></font><br>
<code>java
    private static int hash(int h)
    {
        h += (h &lt;&lt;  15) ^ 0xffffcd7d;
        h ^= (h &gt;&gt;&gt; 10);
        h += (h &lt;&lt;   3);
        h ^= (h &gt;&gt;&gt;  6);
        h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
        return h ^ (h &gt;&gt;&gt; 16);
    }
</code></p>

<pre><code class="java">    //由hash值得到段
    private Segment&lt;K,V&gt; segmentForHash(int h) 
    {
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        return (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);
    }
</code></pre>

<pre><code class="java">    //由给定hash值和段得到HashEntry结点
    static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryForHash(Segment&lt;K,V&gt; seg, int h) 
    {
        HashEntry&lt;K,V&gt;[] tab;
        return (seg == null || (tab = seg.table) == null) ? null :
            (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
            (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
    }
</code></pre>

<p><font color=#0000CD><strong>ConcurrentHashMap并没有重写hashCode方法.</strong></font><br>
<font color=#0000CD><strong>先定位段segment,再确定到段中数组的下标.</strong></font><br></p>

<h2>内部类Segment</h2>

<p><font color=#0000CD><strong>一个ConcurrentHashMap由多个段(Segment)组成,每一个段都包含一个HashEntry结点数组的Hashtable.</strong></font><br></p>

<pre><code class="java">
static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable 
{

    private static final long serialVersionUID = 2249069246763182397L;

    //使用tryLock函数试图获取锁的最大次数
    static final int MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;

    /** 
     * table 是由 HashEntry 对象组成的数组
     * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表
     * table 数组的数组成员代表散列映射表的一个桶
     * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分
     * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 
     */ 
    transient volatile HashEntry&lt;K,V&gt;[] table;

    //段中键值对个数
    transient int count;

    //段中table被更新的次数
    //该变量十分重要
    transient int modCount;

    //阈值
    transient int threshold;

    //装载因子
    final float loadFactor;

    Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) 
    {
        this.loadFactor = lf;
        this.threshold = threshold;
        this.table = tab;
    }
}
</code></pre>

<h2>段内存储元素——Segment类的put函数</h2>

<p><font color=#0000CD><strong>在之前的JDK版本中,Segment的put操作开始时就会先加锁,直到put完成才释放锁.而在JDK7中采用了自旋锁机制,
    进一步减少了加锁的可能性.</strong></font><br></p>

<pre><code class="java">final V put(K key, int hash, V value, boolean onlyIfAbsent) 
{
    //试图获取锁,如果成功获得继续往下执行;如果获取失败调用scanAndLockForPut函数.
    HashEntry&lt;K,V&gt; node = tryLock() ? null :  scanAndLockForPut(key, hash, value);

    V oldValue;

    try {

        HashEntry&lt;K,V&gt;[] tab = table;

        int index = (tab.length - 1) &amp; hash;

        //找到数组对应桶中第一个链表结点
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);

        for (HashEntry&lt;K,V&gt; e = first;;) 
        {
            //如果当前链表结点不为null
            if (e != null) 
            {
                K k;

                //该键已存在,更新该键的值然后退出循环
                if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) 
                {
                    oldValue = e.value;
                    if (!onlyIfAbsent) 
                    {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }

                //继续往链表下一个结点遍历
                e = e.next;
            }
            else //如果当前链表结点为null
            {

                //如果结点链表中没有找到键相当的结点,则新建结点,并将新建结点作为链表头结点插入到链表中
                if (node != null)
                {
                    node.setNext(first);
                }
                else
                {
                    //创建新HashEntry结点
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                }

                int c = count + 1;

                //判断是否需要扩容
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);


                ++modCount;

                count = c;

                oldValue = null;

                break;
            }
        }
    } 
    finally 
    {
        unlock();
    }

    return oldValue;
}
</code></pre>

<p><font color=#0000CD><strong>如果scanAndLockForPut操作返回了一个非空HashEntry,则表示在scanAndLockForPut遍历key对应结点链表时没有找到相应的</strong></font><br>
<font color=#0000CD><strong>此时需要创建新的结点,因而在scanAndLockForPut中预先创建了HashEntry结点.</strong></font><br></p>

<pre><code class="java">static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryAt(HashEntry&lt;K,V&gt;[] tab, int i) 
{
    return (tab == null) ? null :
        (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
        (tab, ((long)i &lt;&lt; TSHIFT) + TBASE);
}
</code></pre>

<pre><code class="java">static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) 
{
    UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);
}
</code></pre>

<p><font color=#0000CD><strong>put操作第一步获取锁未成功则进行scanAndLockForPut操作</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">scanAndLockForPut</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">entryForHash</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//试图获得锁的次数</span>
</span><span class='line'><span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// negative while locating node</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//自旋锁</span>
</span><span class='line'><span class="k">while</span> <span class="o">(!</span><span class="n">tryLock</span><span class="o">())</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span><span class="o">;</span> <span class="c1">// to recheck first below</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">retries</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="c1">//预先新建结点</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>            <span class="o">{</span>
</span><span class='line'>                <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">))</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//尝试次数达到最长次数</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">(++</span><span class="n">retries</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">MAX_SCAN_RETRIES</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">();</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//在自旋过程中发现结点链表的头结点发生了变化,则要更新结点链表的头结点,并重置retries的值为-1</span>
</span><span class='line'>    <span class="c1">//重新为尝试获取锁而自旋遍历.</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">retries</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">f</span> <span class="o">=</span> <span class="n">entryForHash</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">hash</span><span class="o">))</span> <span class="o">!=</span> <span class="n">first</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">e</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="n">f</span><span class="o">;</span> <span class="c1">// re-traverse if entry changed</span>
</span><span class='line'>        <span class="n">retries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#0000CD><strong>由上面put函数源码所示,当put操作尝试加锁没有成功时,它不是直接进入等待状态,而是调用scanAndLockForPut方法.</strong></font><br>
<font color=#0000CD><strong>该操作持续查找key对应的结点链中是已存在该结点,如果没有找到已存在的结点,则预创建一个新结点,并且尝试n次,</strong></font><br>
<font color=#0000CD><strong>直到尝试次数达到操作限制,才真正进入等待状态,即自旋等待.</strong></font><br>
<font color=#FF0000><strong>最大尝试次数,单核次数为1,多核为64.</strong></font><br>
<font color=#FF0000><strong>scanAndLockForPut操作,它先获取key对应的结点链表的头结点,然后持续遍历该链,如果结点链表中不存在要插入的结点,</strong></font><br>
<font color=#0000CD><strong>则预先创建一个结点,否则retries值自增,直到操作最大尝试次数而进入等待状态.</strong></font><br></p>

<h2>段内扩容操作——Segment类的rehash函数</h2>

<p><font color=#0000CD><strong>扩容</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">rehash</span><span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">)</span>
</span><span class='line'><span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;[]</span> <span class="n">oldTable</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">oldCapacity</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">threshold</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">newCapacity</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;[]</span> <span class="n">newTable</span> <span class="o">=</span>
</span><span class='line'>    <span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;[])</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">[</span><span class="n">newCapacity</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">sizeMask</span> <span class="o">=</span> <span class="n">newCapacity</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">oldCapacity</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">sizeMask</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="c1">//  Single node on list</span>
</span><span class='line'>            <span class="n">newTable</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="o">{</span> <span class="c1">// Reuse consecutive sequence at same slot</span>
</span><span class='line'>            <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">lastRun</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">lastIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span> <span class="n">last</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
</span><span class='line'>            <span class="o">{</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">sizeMask</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">lastIdx</span><span class="o">)</span>
</span><span class='line'>                <span class="o">{</span>
</span><span class='line'>                    <span class="n">lastIdx</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">lastRun</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">newTable</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">lastRun</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Clone remaining nodes</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">lastRun</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
</span><span class='line'>            <span class="o">{</span>
</span><span class='line'>                <span class="n">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">sizeMask</span><span class="o">;</span>
</span><span class='line'>                <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
</span><span class='line'>                <span class="n">newTable</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">h</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">nodeIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">sizeMask</span><span class="o">;</span> <span class="c1">// add the new node</span>
</span><span class='line'><span class="n">node</span><span class="o">.</span><span class="na">setNext</span><span class="o">(</span><span class="n">newTable</span><span class="o">[</span><span class="n">nodeIndex</span><span class="o">]);</span>
</span><span class='line'><span class="n">newTable</span><span class="o">[</span><span class="n">nodeIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
</span><span class='line'><span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>段内移除元素——Segment类的remove函数</h2>

<p><font color=#0000CD><strong>只有目前将键的条目映射到给定值时,才移除该键的条目</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="n">V</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">tryLock</span><span class="o">())</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="c1">//第一次获取锁失败,进入自旋状态</span>
</span><span class='line'>        <span class="n">scanAndLock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">try</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">hash</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//得到键key所对应数组的头一个HashEntry结点</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">entryAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//前一个结点</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">pred</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//在结点链表上遍历寻找</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//当前结点的下一个结点</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//找到键所对应的HashEntry结点</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">value</span> <span class="o">==</span> <span class="n">v</span> <span class="o">||</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>            <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                <span class="o">{</span>
</span><span class='line'>                    <span class="c1">//要移除的结点时链表头结点,则将头结点下一个结点设置为头结点</span>
</span><span class='line'>                    <span class="n">setEntryAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="k">else</span>
</span><span class='line'>                <span class="o">{</span>
</span><span class='line'>                    <span class="c1">//将要删除结点的前一个结点的next设置为要删除结点的下一个结点</span>
</span><span class='line'>                    <span class="n">pred</span><span class="o">.</span><span class="na">setNext</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>                <span class="c1">//整个Map的结构变化次数加1</span>
</span><span class='line'>                <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="c1">//当前段内结点个数减1</span>
</span><span class='line'>                <span class="o">--</span><span class="n">count</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">oldValue</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">pred</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>        <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">finally</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">unlock</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#0000CD><strong>
当移除的是链头时则更新数组项的值，否则更新找到节点的前一个节点的next指针。这也是HashEntry中next指针没有设置成final的原因。当然remove操作如果第一次尝试获得锁失败也会如put操作一样先进入自旋状态，这里的scanAndLock和scanAndLockForPut类似，只是它不做预创建节点的步骤</strong></font><br></p>

<p><font color=#0000CD><strong>remove操作中第一步获取锁失败进行scanAndLock操作</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">scanAndLock</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="c1">// similar to but simpler than scanAndLockForPut</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">entryForHash</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//自旋锁</span>
</span><span class='line'><span class="k">while</span> <span class="o">(!</span><span class="n">tryLock</span><span class="o">())</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">retries</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">))</span>
</span><span class='line'>            <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">(++</span><span class="n">retries</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">MAX_SCAN_RETRIES</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">();</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">retries</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">f</span> <span class="o">=</span> <span class="n">entryForHash</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">hash</span><span class="o">))</span> <span class="o">!=</span> <span class="n">first</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">e</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="n">f</span><span class="o">;</span>
</span><span class='line'>        <span class="n">retries</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#0000CD><strong>scanAndLock和scanAndLockForPut类似,只是它不做预创建节点的步骤</strong></font><br></p>

<h2>段内替换操作1——Segment类的replace函数</h2>

<pre><code class="java">final boolean replace(K key, int hash, V oldValue, V newValue) 
{
    if (!tryLock())
    {
        scanAndLock(key, hash);
    }

    boolean replaced = false;
    try 
    {
        HashEntry&lt;K,V&gt; e;
        for (e = entryForHash(this, hash); e != null; e = e.next) 
        {
            K k;
            if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) 
            {
                if (oldValue.equals(e.value)) 
                {
                    e.value = newValue;
                    ++modCount;
                    replaced = true;
                }
                break;
            }
        }
    } 
    finally 
    {
        unlock();
    }
    return replaced;
}
</code></pre>

<h2>段内替换操作2——Segment类的replace函数</h2>

<pre><code class="java">final V replace(K key, int hash, V value) 
{
    if (!tryLock())
    {
        scanAndLock(key, hash);
    }

    V oldValue = null;
    try 
    {
        HashEntry&lt;K,V&gt; e;
        for (e = entryForHash(this, hash); e != null; e = e.next) 
        {
            K k;
            if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) 
            {
                oldValue = e.value;
                e.value = value;
                ++modCount;
                break;
            }
        }
    } 
    finally 
    {
        unlock();
    }
    return oldValue;
}
</code></pre>

<h2>段内清除操作——Segment类的clear函数</h2>

<pre><code class="java">final void clear() 
{
    lock();//加锁
    try 
    {
        HashEntry&lt;K,V&gt;[] tab = table;
        for (int i = 0; i &lt; tab.length ; i++)
        {
            setEntryAt(tab, i, null);
        }
        ++modCount;
        count = 0;
    } 
    finally 
    {
        unlock();//释放锁
    }
}
</code></pre>

<h2>存储元素——put函数</h2>

<p><font color=#0000CD><strong>公用的put函数将put操作委托给Segment类的put方法</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//值不能为null</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//直接调用key的hasCode方法，所以键key不能为null</span>
</span><span class='line'><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//得到hash值对应的 segments 数组的下标值</span>
</span><span class='line'><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">segmentShift</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">segmentMask</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//根据下标值返回散列码对应的Segment对象</span>
</span><span class='line'><span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObject</span><span class="o">(</span><span class="n">segments</span><span class="o">,</span> <span class="o">(</span><span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">SSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">SBASE</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">s</span> <span class="o">=</span> <span class="n">ensureSegment</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//委托给段的put函数来完成</span>
</span><span class='line'><span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">font</span> <span class="n">color</span><span class="o">=</span><span class="err">#</span><span class="n">FF0000</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;**</span><span class="n">ConcurrentHashMap中键和值都不能为null</span><span class="o">.**&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">font</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">font</span> <span class="n">color</span><span class="o">=</span><span class="err">#</span><span class="mi">0000</span><span class="n">CD</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;**</span><span class="n">ensureSegment函数</span><span class="o">**&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">font</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">br</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">font</span> <span class="n">color</span><span class="o">=</span><span class="err">#</span><span class="mi">0000</span><span class="n">CD</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;**</span><span class="n">按给定的下标来返回Segment对象</span><span class="o">,</span><span class="n">如果不存在</span><span class="err">，</span><span class="n">要在该数组下标下新建Segment对象</span><span class="o">.**&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">font</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">br</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span>
</span><span class='line'><span class="kd">private</span> <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">ensureSegment</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">SSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">SBASE</span><span class="o">;</span> <span class="c1">// raw offset</span>
</span><span class='line'>
</span><span class='line'><span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">seg</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">((</span><span class="n">seg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">proto</span> <span class="o">=</span> <span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="na">table</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">lf</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="na">loadFactor</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">cap</span> <span class="o">*</span> <span class="n">lf</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;[])</span><span class="k">new</span> <span class="n">HashEntry</span><span class="o">[</span><span class="n">cap</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">((</span><span class="n">seg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">lf</span><span class="o">,</span> <span class="n">threshold</span><span class="o">,</span> <span class="n">tab</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span> <span class="o">((</span><span class="n">seg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">ss</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">seg</span> <span class="o">=</span> <span class="n">s</span><span class="o">))</span>
</span><span class='line'>                <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">seg</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#0000CD><strong>ensureSegment函数使用CAS来实现.</strong></font><br></p>

<h2>读取元素——get函数</h2>

<p><font color=#0000CD><strong>返回指定键所映射到的值,如果此映射不包含该键的映射关系,则返回null。</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;[]</span> <span class="n">tab</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'><span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(((</span><span class="n">h</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">segmentShift</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">segmentMask</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">SSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">SBASE</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">segments</span><span class="o">,</span> <span class="n">u</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
</span><span class='line'>    <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">HashEntry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span>
</span><span class='line'>             <span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="o">((</span><span class="kt">long</span><span class="o">)(((</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">h</span><span class="o">))</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">TSHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">TBASE</span><span class="o">);</span>
</span><span class='line'>         <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure>
<font color=#0000CD><strong>ConcurrentHashMap中读并没有加锁.</strong></font><br></p>

<h2>公用非全局操作——get()/containsKey()/put()/putIfAbsent()/replace()/Remove()/clear()操作</h2>

<p><font color=#0000CD><strong>这些操作只需要找到相应的Segment对象,通过Segment找到结点链表,然后遍历结点链表即可.</strong></font><br>
<font color=#0000CD><strong>这些操作都是局限在某一个Segment内.</strong></font><br></p>

<h3>公用remove()函数</h3>

<p><font color=#0000CD><strong>只有目前将键的条目映射到给定值时,才移除该键的条目</strong></font><br>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
</span><span class='line'>    <span class="n">Segment</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">////委托给段的remove函数来完成</span>
</span><span class='line'><span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">segmentForHash</span><span class="o">(</span><span class="n">hash</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span>
</span><span class='line'>    <span class="n">s</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>公用全局操作——size()/containsValue()/contains()/isEmpty()操作</h2>

<p><font color=#0000CD><strong>这些操作需要全局扫描整个Map,正常情况下需要先获得所有Segment实例的锁，然后做相应的查找、计算得到结果，再解锁，返回值。然而为了竟可能的减少锁对性能的影响，Doug Lea在这里并没有直接加锁，而是先尝试的遍历查找、计算2遍，如果两遍遍历过程中整个Map没有发生修改（即两次所有Segment实例中modCount值的和一致），则可以认为整个查找、计算过程中Map没有发生改变，我们计算的结果是正确的，否则，在顺序的在所有Segment实例加锁，计算，解锁，然后返回。</strong></font><br></p>

<h3>公用size()函数</h3>

<pre><code class="java">public int size() 
{

    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try 
    {
        for (;;) 
        {
            //达到了非同步可尝试次数上限,开始加锁
            if (retries++ == RETRIES_BEFORE_LOCK) 
            {
                //所有段都加锁，支持全局操作
                for (int j = 0; j &lt; segments.length; ++j)
                {
                    ensureSegment(j).lock(); // force creation
                }
            }
            sum = 0L;
            size = 0;
            overflow = false;

            //统计各段size的总和.
            for (int j = 0; j &lt; segments.length; ++j) 
            {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);

                if (seg != null) 
                {
                    sum += seg.modCount;
                    int c = seg.count;

                    if (c &lt; 0 || (size += c) &lt; 0)
                    {
                        overflow = true;
                    }
                }
            }

            //前后两次modCount值的和不变,则认为整个Map没有改变,计算结果有效,退出循环
            if (sum == last)
            {
                break;
            }   

            last = sum;
        }
    } 
    finally 
    {
        if (retries &gt; RETRIES_BEFORE_LOCK) 
        {
            for (int j = 0; j &lt; segments.length; ++j)
            {
                segmentAt(segments, j).unlock();
            }
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
</code></pre>

<p><font color=#0000CD><strong>可以看到在size()函数中，先在不加锁的情况下遍历Segment数组，计算size总和和modCount总和;</strong></font><br>
<font color=#0000CD><strong>若两次modCount总和一样，说明整个Map都没有发生变化,统计的size总和是有效的，不需要再加锁统计.</strong></font><br>
<font color=#0000CD><strong>若两次modCount总和有变,则说明整个Map发生了变化,统计的size总和可能是不准确的,需要给各个段加锁统计.</strong></font><br></p>

<h3>公用containsValue()函数</h3>

<pre><code class="java">public boolean containsValue(Object value) 
{
    if (value == null)
    {
        throw new NullPointerException();
    }

    final Segment&lt;K,V&gt;[] segments = this.segments;
    boolean found = false;
    long last = 0;
    int retries = -1;

    try {
        outer: for (;;) 
        {
            if (retries++ == RETRIES_BEFORE_LOCK) 
            {
                for (int j = 0; j &lt; segments.length; ++j)
                {
                    ensureSegment(j).lock(); // force creation
                }
            }

            long hashSum = 0L;
            int sum = 0;
            for (int j = 0; j &lt; segments.length; ++j) 
            {
                HashEntry&lt;K,V&gt;[] tab;
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);

                if (seg != null &amp;&amp; (tab = seg.table) != null) 
                {
                    for (int i = 0 ; i &lt; tab.length; i++) 
                    {
                        HashEntry&lt;K,V&gt; e;
                        for (e = entryAt(tab, i); e != null; e = e.next) 
                        {
                            V v = e.value;
                            if (v != null &amp;&amp; value.equals(v)) 
                            {
                                found = true;
                                break outer;
                            }
                        }
                    }
                    sum += seg.modCount;
                }
            }
            if (retries &gt; 0 &amp;&amp; sum == last)
            {
                break;
            }
            last = sum;
        }
    } 
    finally 
    {
        if (retries &gt; RETRIES_BEFORE_LOCK) 
        {
            for (int j = 0; j &lt; segments.length; ++j)
            {
                segmentAt(segments, j).unlock();
            }

        }
    }
    return found;
}
</code></pre>

<p><font color=#0000CD><strong>containsValue函数也使用了size()函数中思路，先不加锁计算两次;如果计算是无效的再加锁统计.</strong></font><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hashtable源码分析]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/25/hashtable/"/>
    <updated>2016-07-25T13:26:15+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/25/hashtable</id>
    <content type="html"><![CDATA[<p><font color=#FF0000><strong>Hashtable在Map框架图中的位置</strong></font><br>
<img src="/images/Hashtable1.jpg"></p>

<h2>1.定义</h2>

<p>public class Hashtable&lt;K,V> extends Dictionary&lt;K,V> implements Map&lt;K,V>, Cloneable, java.io.Serializable</p>

<p>public class HashMap&lt;K,V> extends AbstractMap&lt;K,V>  implements Map&lt;K,V>, Cloneable, Serializable</p>

<p><font color=#0000CD><strong>Hashtable实现了Map接口，继承了Dictionary类，其中Map接口定义了键值的映射规则，而Dictionary类是任何可将键映射到相应值的类的抽象父类.</strong></font></p>

<p><font color=#FF0000><strong>Hashtable中的函数都是用了synchronized关键字进行同步，是线程安全的;而HashMap则没有，不是线程安全的.</strong></font><br></p>

<h2>2.Hashtable类中变量</h2>

<pre><code>//Hashtable的底层类似于HashMap也是基于数组和链表来实现,其中的数组指的的table数组
private transient Entry[] table;

private transient int count;//存储的键值对个数

private int threshold;//阈值 当实际大小超过阈值时，会进行扩容  阈值=容量*加载因子


private float loadFactor;//加载因子


private transient int modCount = 0;//Hashtable结构被改变的次数

private static final long serialVersionUID = 1421746759512286392L;//序列号
</code></pre>

<h2>Hashtable中的数据结构</h2>

<p><font color=#0000CD><strong>Hashtable的底层结构与HashMap类似，都是数组加链表.</strong></font><br>
<img src="/images/Hashtable2.jpg"></p>

<h2>Hashtable类的构造函数</h2>

<pre><code>//用指定初始容量和指定加载因子构造一个新的空哈希表
public Hashtable(int initialCapacity, float loadFactor) 
{
    //检查参数是否合法
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    //检查参数是否合法
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal Load: "+loadFactor);

    if (initialCapacity==0)
        initialCapacity = 1;

    this.loadFactor = loadFactor;

    //初始化一个大小为initialCapacity的Entry数组(table数组)
    table = new Entry[initialCapacity];

    //阈值等于初始容量*装载因子
    threshold = (int)(initialCapacity * loadFactor);
}

//用指定初始容量和默认的加载因子0.75构造一个新的空哈希表
public Hashtable(int initialCapacity) 
{
    this(initialCapacity, 0.75f);
}

//用默认的初始容量11和加载因子0.75构造一个新的空哈希表
public Hashtable() 
{
    this(11, 0.75f);
}

//构造一个与给定的 Map 具有相同映射关系的新哈希表
public Hashtable(Map&lt;? extends K, ? extends V&gt; t) 
{
    this(Math.max(2*t.size(), 11), 0.75f);
    putAll(t);
}
</code></pre>

<p><strong>Entry为Hashtable的静态内部类</strong><br>
<font color=#0000CD><strong>链表上的结点都是由Entry对象组成.</strong></font><br>
<font color=#0000CD><strong>Hashtable中的内部类Entry与HashMap中的内部类Entry类似.</strong></font><br>
```java
   private static class Entry&lt;K,V> implements Map.Entry&lt;K,V>
   {
        int hash; //hash值
        K key;  //键 key
        V value;//值 value
        Entry&lt;K,V> next;//下一个结点</p>

<pre><code>    protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) 
    {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    protected Object clone() 
    {
        return new Entry&lt;&gt;(hash, key, value,
                              (next==null ? null : (Entry&lt;K,V&gt;) next.clone()));
    }

    public K getKey() 
    {
        return key;
    }

    public V getValue() 
    {
        return value;
    }

    public V setValue(V value) 
    {
        if (value == null)
            throw new NullPointerException();

        V oldValue = this.value;
        this.value = value;
        return oldValue;
    }

    //判断结点是否相等
    public boolean equals(Object o) 
    {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;

        return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;
           (value==null ? e.getValue()==null : value.equals(e.getValue()));
    }

    public int hashCode() 
    {
        return hash ^ (value==null ? 0 : value.hashCode());
    }

    public String toString() 
    {
        return key.toString()+"="+value.toString();
    }
}
</code></pre>

<pre><code>
##计算添加元素的位置
</code></pre>

<pre><code>public synchronized int hashCode() 
{

    int h = 0;

    if (count == 0 || loadFactor &lt; 0)
    {
        return h;  // Returns zero
    }

    loadFactor = -loadFactor;  // Mark hashCode computation in progress

    Entry[] tab = table;

    for (int i = 0; i &lt; tab.length; i++)
        for (Entry e = tab[i]; e != null; e = e.next)
            h += e.key.hashCode() ^ e.value.hashCode();

    loadFactor = -loadFactor;  // Mark hashCode computation complete

    return h;
}
</code></pre>

<pre><code>&lt;font color=#0000CD&gt;**Hashtable重写了hashCode函数来计算键的hash值**&lt;/font&gt;&lt;br&gt;
&lt;font color=#0000CD&gt;**这也是与HashMap的不同，HashMap中先使用hashCode函数再使用hash函数来计算数组下标.**&lt;/font&gt;&lt;br&gt;
&lt;font color=#0000CD&gt;**而Hashtable中先使用hashCode函数再使用(hash &amp; 0x7FFFFFFF) % tab.length运算来计算数组下标.**&lt;/font&gt;&lt;br&gt;

##存储元素——put函数
</code></pre>

<pre><code>public synchronized V put(K key, V value) 
{
    //Hashtable对象中不允许存储的值为null
    if (value == null) 
    {
        throw new NullPointerException();
    }

    Entry tab[] = table;

    //使用hashCode函数计算键的hash值
    //键key不能为null,如果为null,这里要抛出NullPointerException异常
    int hash = key.hashCode();

    //计算键在table数组的下标
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;

    //如果键已经在Hashtable中，则只需更新该键的值即可
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) 
    {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) 
        {
            V old = e.value;
            e.value = value;
            return old;
        }
    }

    modCount++;

    //增加一个键值对后要判断Hashtable中键值对个数是否超过阈值
    if (count &gt;= threshold) //超过阈值则要进行扩容
    {
        //调用rehash函数对Hashtable进行扩容
        rehash();

        tab = table;

        index = (hash &amp; 0x7FFFFFFF) % tab.length;
    }

    //将当前位置上的结点作为新结点的下一个结点.
    Entry&lt;K,V&gt; e = tab[index];

    //新建Entry结点,并将其存储在数组中
    tab[index] = new Entry&lt;&gt;(hash, key, value, e);

    count++;

    return null;
}
</code></pre>

<pre><code>
&lt;font color=#0000CD&gt;**注意Hashtable中键(key)和值(value)都不能为null,这是与HashMap不同的;**&lt;/font&gt;&lt;br&gt;
&lt;font color=#0000CD&gt;**HashMap允许一个为null键(key)和任一个为null的值(value).**&lt;/font&gt;&lt;br&gt;


&lt;font color=#0000CD&gt;**Hashtable扩容-rehash函数**&lt;/font&gt;&lt;br&gt;
</code></pre>

<pre><code>protected void rehash() 
{
    int oldCapacity = table.length;

    Entry[] oldMap = table;

    //新容量为旧容量的两倍再加1
    int newCapacity = (oldCapacity &lt;&lt; 1) + 1;

    //到达容量极限
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) 
    {
        if (oldCapacity == MAX_ARRAY_SIZE)
        {
            return;
        }

        newCapacity = MAX_ARRAY_SIZE;
    }

    //以新容量新建一个Entry数组
    Entry[] newMap = new Entry[newCapacity];

    modCount++;

    //计算新的阈值
    threshold = (int)(newCapacity * loadFactor);

    table = newMap;

    //依次将旧table数组中的所有结点拷贝到新的table数组中.
    for (int i = oldCapacity ; i-- &gt; 0 ;)
    {
        for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) 
        {
            Entry&lt;K,V&gt; e = old;
            old = old.next;

            int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;
            e.next = newMap[index];
            newMap[index] = e;
        }
    }
}
</code></pre>

<pre><code>&lt;font color=#0000CD&gt;**Hashtable扩容上也与HashMap不一样,HashMap中新数组大小直接扩为原数组的2倍，而Hashtable是扩为原数组大小的2倍再加1.**&lt;/font&gt;&lt;br&gt;


##读取元素——get函数
&lt;font color=#0000CD&gt;**给返回指定键所映射到的值**&lt;/font&gt;&lt;br&gt;
</code></pre>

<pre><code>public synchronized V get(Object key) 
{
    Entry tab[] = table;

    //计算该键的hash值
    int hash = key.hashCode();

    //计算该键对象的数组下标
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;

    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) 
    {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) 
        {
            return e.value;
        }
    }

    //如果此Hashtable不包含此键的映射，则返回null
    return null;
}
</code></pre>

<pre><code>
##移除元素——remove函数
&lt;font color=#0000CD&gt;**从哈希表中移除该键及其相应的值**&lt;/font&gt;&lt;br&gt;
</code></pre>

<pre><code>public synchronized V remove(Object key) 
{

    Entry tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;

    //在table数组中下标为index的位置寻找该键
    for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) 
    {
        //找到该键对应的值
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) 
        {
            modCount++;

            if (prev != null) 
            {
                prev.next = e.next;
            } 
            else
            {
                tab[index] = e.next;
            }

            count--;

            V oldValue = e.value;
            e.value = null;
            return oldValue;
        }
    }

    //如果该键不在Hashtable中,则此返回null,不执行任何操作
    return null;
}
</code></pre>

<pre><code>
##equals函数
&lt;font color=#0000CD&gt;**Hashtable重写了equals方法**&lt;/font&gt;&lt;br&gt;
</code></pre>

<pre><code>public synchronized boolean equals(Object o) 
{
    //直接使用"==",比较对象地址
    if (o == this)
    {
        return true;
    }


    if (!(o instanceof Map))
    {
        return false;
    }

    Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o;

    if (t.size() != size())
    {
        return false;
    }

    try 
    {
        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();

        while (i.hasNext()) 
        {
            Map.Entry&lt;K,V&gt; e = i.next();
            K key = e.getKey();
            V value = e.getValue();

            if (value == null)
            {
                if (!(t.get(key)==null &amp;&amp; t.containsKey(key)))
                {
                    return false;
                }
            } 
            else 
            {
                if (!value.equals(t.get(key)))
                    return false;
            }
        }
    } 
    catch (ClassCastException unused)   
    {
        return false;
    } 
    catch (NullPointerException unused) 
    {
        return false;
    }

    return true;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java的七种垃圾收集器]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/22/seven-gc/"/>
    <updated>2016-07-22T16:28:25+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/22/seven-gc</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java垃圾收集机制]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/22/java-gc/"/>
    <updated>2016-07-22T15:10:49+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/22/java-gc</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
