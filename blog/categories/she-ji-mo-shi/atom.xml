<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | regenthypo's Blog]]></title>
  <link href="http://www.regenthypo.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://www.regenthypo.com/"/>
  <updated>2016-07-05T16:52:56+08:00</updated>
  <id>http://www.regenthypo.com/</id>
  <author>
    <name><![CDATA[regenthypo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之中介者模式[6]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/05/mediator-design-pattern/"/>
    <updated>2016-07-05T15:41:38+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/05/mediator-design-pattern</id>
    <content type="html"><![CDATA[<p>[行为模式]</p>

<p>意图:用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且
可以独立地改变它们之间的交互.<br></p>

<p><img src="/images/mediatordp1.jpg"></p>

<p><img src="/images/mediatordp2.jpg"></p>

<p><img src="/images/mediatordp3.jpg"></p>

<pre><code class="java Mediator.java">/**
 *  抽象中介者角色 
 */
public abstract class Mediator
{
    //事件方法,由子类实现
    public abstract void colleagueChanged(Colleague c);
}
</code></pre>

<pre><code class="java ConcreteMediator.java">/**
 *  具体中介者角色 
 */
public class ConcreteMediator extends Mediator
{
    //具体中介者知道所有的具体同事类
    private Colleague1 colleague1;
    private Colleague2 colleague2;

    //事件方法的具体实现
    @Override
    public void colleagueChanged(Colleague c)
    {
        colleague1.action();
        colleague2.action();
    }

    //工厂方法,创建同事对象
    public void createConcreteMediator()
    {
        colleague1 = new Colleague1(this);
        colleague2 = new Colleague2(this);
    }

    //取值方法,提供同事对象 
    public Colleague1 getColleague1()
    {
        return colleague1;
    }

    //取值方法,提供同事对象 
    public Colleague2 getColleague2()
    {
        return colleague2;
    }
}
</code></pre>

<pre><code class="java Colleague.java">/**
 *  抽象同事类 
 */
public abstract class Colleague
{
    private Mediator mediator;

    public Colleague(Mediator mediator)
    {
        this.mediator = mediator;
    }

    //取值方法,提供中介者对象
    public Mediator getMediator()
    {
        return mediator;
    }

    //行动方法,有子类实现
    public abstract void action();

    //示意性的商业方法,调用此方法可以改变对象的内部状态
    public void change()
    {
        mediator.colleagueChanged(this);
    }
}
</code></pre>

<pre><code class="java Colleague1.java">/**
 *  具体同事类 
 *  每一个同事对象都仅知道中介者,而不知道其他的同事对象
 */
public class Colleague1 extends Colleague
{
    public Colleague1(Mediator mediator)
    {
        super(mediator);
    }

    //行动方法的具体实现
    @Override
    public void action()
    {
        System.out.println("action from colleague1");
    }
}
</code></pre>

<pre><code class="java Colleague2.java">/**
 *  具体同事类 
 *  每一个同事对象都仅知道中介者,而不知道其他的同事对象
 */
public class Colleague2 extends Colleague
{
    public Colleague2(Mediator mediator)
    {
        super(mediator);
    }

    //行动方法的具体实现
    @Override
    public void action()
    {
        System.out.println("action from colleague2");
    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        ConcreteMediator mediator = new ConcreteMediator();

        mediator.createConcreteMediator();

        Colleague1 c1 = new Colleague1(mediator);
        Colleague2 c2 = new Colleague2(mediator);

        mediator.colleagueChanged(c1);
    }
}
</code></pre>

<p><img src="/images/mediatordp4.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之策略模式[5]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/05/strategy-design-pattern/"/>
    <updated>2016-07-05T14:39:38+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/05/strategy-design-pattern</id>
    <content type="html"><![CDATA[<p>[行为模式]</p>

<p>意图:定义一系列的算法,将每一个算法封装到具有共同接口的独立的类中,从而使得他们可以相互替换.本模式可以使得算法可以独立于使用它的客户而变化.<br></p>

<p>策略模式把行为和环境分割开来。环境类负责维护和查询行为类，各种算法则在具体策略类中提供。由于算法和环境独立开来，
算法的增减、修改都不会影响环境和客户端。<br></p>

<p><img src="/images/strategydp1.jpg"></p>

<p><img src="/images/strategydp2.jpg"></p>

<pre><code class="java Context.java">/**
 *  环境角色 
 */
public class Context
{
    private Strategy strategy;

    public Strategy getStrategy()
    {
        return strategy;
    }

    public void setStrategy(Strategy strategy)
    {
        this.strategy = strategy;
    }

    //策略方法
    public void operation()
    {
        strategy.action();
    }
}
</code></pre>

<pre><code class="java Strategy.java">/**
 *  抽象策略角色 
 */
public abstract class Strategy
{
    //策略方法
    public abstract void action();//具体策略类要实现的共同接口
}
</code></pre>

<pre><code class="java ConcreteStrategy1.java">/**
 *  具体策略角色 
 */
public class ConcreteStrategy1 extends Strategy
{
    @Override
    public void action()//策略方法
    {
        //实现算法
        System.out.println("strategy1 operation.");
    }
}
</code></pre>

<pre><code class="java ConcreteStrategy2.java">/**
 *  具体策略角色 
 */
public class ConcreteStrategy2 extends Strategy
{
    @Override
    public void action()
    {
        //实现算法
        System.out.println("strategy2 operation.");
    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        Context context = new Context();

        context.setStrategy(new ConcreteStrategy1());
        context.operation();

        context.setStrategy(new ConcreteStrategy2());
        context.operation();
    }
}
</code></pre>

<p><img src="/images/strategydp3.jpg"></p>

<p><img src="/images/strategydp4.jpg"></p>

<p><img src="/images/strategydp5.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之工厂模式[1]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/06/25/factory-pattern/"/>
    <updated>2016-06-25T14:43:37+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/06/25/factory-pattern</id>
    <content type="html"><![CDATA[<p>[创建型模式]</p>

<p>工厂模式专门负责将大量有共同接口的类实例化.工厂模式可以动态决定将哪一个类实例化，不必
事先知道每次要实例化哪一个类.工厂模式有以下几种形态:<br>
简单工厂(Simple Factory)模式: 又称静态工厂方法模式.<br>
工厂方法(Factory Method)模式: 又称多态性工厂模式或虚拟构造子(Virtual Constructor)模式.<br>
抽象工厂(Abstract Factory)模式:又称工具箱模式.<br></p>

<h1>简单工厂模式</h1>

<p>简单工厂模式 Simple Factory 又称静态工厂方法模式</p>

<p>&hellip;.简单工厂模式就是一个工厂类根据传入的参量决定创建出哪一种产品类的实例.</p>

<p>简单工厂涉及三个角色<br>
&mdash;-工厂类角色     ：担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象。<br></p>

<p>&mdash;-抽象产品角色: 担任这个角色的类是由工厂方法模式所创建的对象的父类，或他们的共同拥有的接口。可以是一个Java接口或Java抽象类<br></p>

<p>&mdash;-具体产品角色:工厂方法模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现.<br></p>

<pre><code class="java Fruit.java">package DP1_1.SimpleFactory;

/**
 * 抽象产品接口/抽象类
 */
public interface Fruit
{
    void grow();//生长

    void harvest();//收获

    void plant();//种植
}
</code></pre>

<p>以下三个类Apple,Grape,StrawBerry均实现了Fruit接口.<br></p>

<pre><code class="java Apple.java">/**
 *  具体产品类 
 */
public class Apple implements Fruit
{
    private int treeAge ;
    @Override
    public void grow()
    {
        log("apple is growing...");
    }

    @Override
    public void harvest()
    {
        log("apple has harvested!!!");
    }

    @Override
    public void plant()
    {
        log("apple has planted!!!");
    }

//  辅助方法
    public static void log(String msg)
    {
        System.out.println(msg);
    }

//    树龄的取值方法
    public int getTreeAge()
    {
        return treeAge;
    }

//  树龄的赋值方法
    public void setTreeAge(int treeAge)
    {
        this.treeAge = treeAge;
    }
}
</code></pre>

<pre><code class="java Grape.java">/**
 *  具体产品类 
 */
public class Grape implements Fruit
{
    private boolean seedless;
    @Override
    public void grow()
    {
        log("grape is growing...");
    }

    @Override
    public void harvest()
    {
        log("grape has harvested!!!");
    }

    @Override
    public void plant()
    {
        log("grape has planted!!!");
    }

//  辅助方法
    public static void log(String msg)
    {
        System.out.println(msg);
    }

//  有无仔的取值方法    
    private boolean getSeedless()
    {
        return seedless;
    }

//  有无仔的赋值方法
    public void setSeedless(boolean seedless)
    {
        this.seedless = seedless;
    }
}
</code></pre>

<pre><code class="java StrawBerry.java">/**
 *  具体产品类 
 */
public class StrawBerry implements Fruit
{
    @Override
    public void grow()
    {
        log("strawberry is growing...");
    }

    @Override
    public void harvest()
    {
        log("strawberry has harvested!!!");
    }

    @Override
    public void plant()
    {
        log("strawberry has planted!!!");
    }

//  辅助方法
    public static void log(String msg)
    {
        System.out.println(msg);
    }
}
</code></pre>

<pre><code class="java BadFruitException.java">public class BadFruitException extends Exception
{
    public BadFruitException(String msg)
    {
        super(msg);
    }
}
</code></pre>

<p>工厂类 <br>
FruitGardener类会根据客户端的要求,创建出不同的水果对象,比如Apple,Grape,或StrawBerry的实例.
而如果接到不合法的要求,FruitGardener类会抛出BadFruitException异常.<br></p>

<pre><code class="java FruitGardener.java">public class FruitGardener
{
    /**
     * 工厂类      静态工厂方法
     */
    public static Fruit factory(String which) throws BadFruitException
    {
        if(which.equalsIgnoreCase("apple"))
        {
            return new Apple();
        }
        else if(which.equalsIgnoreCase("grape"))
        {
            return new Grape();
        }
        else if(which.equalsIgnoreCase("strawberry"))
        {
            return new StrawBerry();
        }
        else
        {
            throw new BadFruitException("Bad fruit request");
        }
    }
}
</code></pre>

<p>测试类<br></p>

<pre><code class="java test.java">package DP1_1.SimpleFactory;

public class test
{
    public static void main(String[] args)
    {
        try
        {
            FruitGardener.factory("apple").grow();;
            FruitGardener.factory("grape");
            FruitGardener.factory("strawberry");
            //FruitGardener.factory("banana");
        } catch (BadFruitException e)
        {
            e.printStackTrace();
        }
    }

}
</code></pre>

<p>抽象产品角色可使用Java接口或Java抽象类来实现.<br>
    如果模式所产生的具体产品类彼此之间没有共同的商业逻辑,那么抽象产品角色可以由一个
Java接口扮演;<br>
    相反,如果这些具体产品类彼此之间确实有共同的商业逻辑,那么这些公有的逻辑就应该移动抽象角
色里面,这就意味着抽象角色应该由一个抽象类扮演;<br>
    在一个类型的等级结构里面,共同的代码应当尽量向上移动,以达到共享的目的.<br></p>

<p><img src="/images/factory1.jpg"></p>

<p><img src="/images/factory2.jpg"></p>

<h1>工厂方法模式</h1>

<p>[创建型模式]</p>

<p>工厂方法模式意图:定义一个用于创建对象的接口,让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类.<br></p>

<p>由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<br>
  首先，在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类
去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类被实例化这种细节。<br></p>

<p>  这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，这一特点无疑使得工厂模式具有超过简单工厂模式的优越性.<br>
<img src="/images/factory3.jpg">
<img src="/images/factory4.jpg"></p>

<p>模式结构<br>
<img src="/images/factory5.jpg"></p>

<pre><code class="java Fruit.java">/**
 * 抽象产品接口/抽象类
 */
public interface Fruit
{
    void grow();//生长

    void harvest();//收获

    void plant();//种植
}
</code></pre>

<pre><code class="java FruitGardener.java">/**
 *  抽象工厂角色 
 */
public interface FruitGardener
{
//  工厂方法
    public Fruit factory();//返回值是抽象产品Fruit接口的引用
}
</code></pre>

<pre><code class="java Apple.java">package DP1_2.Factory_Method;

/**
 *  具体产品类, 实现抽象产品类(接口)
 */
public class Apple implements Fruit
{
    private int treeAge ;
    @Override
    public void grow()
    {
        log("apple is growing...");
    }

    @Override
    public void harvest()
    {
        log("apple has harvested!!!");
    }

    @Override
    public void plant()
    {
        log("apple has planted!!!");
    }

//  辅助方法
    public static void log(String msg)
    {
        System.out.println(msg);
    }

//    树龄的取值方法
    public int getTreeAge()
    {
        return treeAge;
    }

//  树龄的赋值方法
    public void setTreeAge(int treeAge)
    {
        this.treeAge = treeAge;
    }
}
</code></pre>

<pre><code class="java AppleFactory.java">/**
 *  具体工厂类 
 */
public class AppleFactory implements FruitGardener
{
    /**
     * 工厂方法
     */
    @Override
    public Fruit factory()//返回值是抽象产品Fruit接口的引用
    {
        // TODO Auto-generated method stub
        return new Apple();
    }
}
</code></pre>

<pre><code class="java Grape.java">//具体产品类 
public class Grape implements Fruit
{
    private boolean seedless;
    @Override
    public void grow()
    {
        log("grape is growing...");
    }

    @Override
    public void harvest()
    {
        log("grape has harvested!!!");
    }

    @Override
    public void plant()
    {
        log("grape has planted!!!");
    }

//  辅助方法
    public static void log(String msg)
    {
        System.out.println(msg);
    }

//  有无仔的取值方法    
    private boolean getSeedless()
    {
        return seedless;
    }

//  有无仔的赋值方法
    public void setSeedless(boolean seedless)
    {
        this.seedless = seedless;
    }
}
</code></pre>

<pre><code class="java GrapeFactory.java">//具体工厂类 
public class GrapeFactory implements FruitGardener
{
    @Override
    public Fruit factory()
    {
        // TODO Auto-generated method stub
        return new Grape();
    }
}
</code></pre>

<pre><code class="java StrawBerry.java">//具体产品类 
public class StrawBerry implements Fruit
{
    @Override
    public void grow()
    {
        log("strawberry is growing...");
    }

    @Override
    public void harvest()
    {
        log("strawberry has harvested!!!");
    }

    @Override
    public void plant()
    {
        log("strawberry has planted!!!");
    }

//  辅助方法
    public static void log(String msg)
    {
        System.out.println(msg);
    }
}
</code></pre>

<pre><code class="java StrawBerryFactory.java">//具体工厂类 
public class StrawBerryFactory implements FruitGardener
{
    @Override
    public Fruit factory()
    {
        // TODO Auto-generated method stub
        return new StrawBerry();
    }
}
</code></pre>

<pre><code class="java BadFruitException.java">public class BadFruitException extends Exception
{
    public BadFruitException(String msg)
    {
        super(msg);
    }
}
</code></pre>

<p>测试类<br>
<figure class='code'><figcaption><span>test.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">test</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">AppleFactory</span> <span class="n">applefactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AppleFactory</span><span class="o">();&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="n">Fruit</span> <span class="n">f</span> <span class="o">=</span> <span class="n">applefactory</span><span class="o">.</span><span class="na">factory</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">f</span><span class="o">.</span><span class="na">grow</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h1>抽象工厂模式</h1>

<p>[创建模式]</p>

<p>抽象工厂模式意图:提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br></p>

<p>抽象工厂模式中的角色<br>
<img src="/images/factory6.jpg"></p>

<p>模式结构<br>
<img src="/images/factory7.jpg"></p>

<p>以下代码结构<br>
<img src="/images/factory8.jpg"></p>

<pre><code class="java Fruit.java">//抽象产品角色 水果
public interface Fruit
{}
</code></pre>

<pre><code class="java Gardener.java">//抽象工厂角色
public interface Gardener//标识接口
{}
</code></pre>

<pre><code class="java NorthernFruit.java">/**
 *  具体产品类 
 */
public class NorthernFruit implements Fruit
{
    private String name;

    public NorthernFruit(String name)
    {
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}
</code></pre>

<pre><code class="java NorthernGardener.java">/**
 *  具体工厂类  生产北方水果、蔬菜
 */
public class NorthernGardener implements Gardener
{
    /**
     * 水果的工厂方法
     */
    public Fruit createFruit(String name)
    {
        return new NorthernFruit(name);
    }

    /**
     * 蔬菜的工厂方法
     */
    public Veggie createVeggie(String name) 
    {
        return new NorthernVeggie(name);
    }
}
</code></pre>

<pre><code class="java TropicalFruit.java">/**
 *  具体产品类 
 */
public class TropicalFruit implements Fruit
{
    private String name;

    public TropicalFruit(String name)
    {
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}
</code></pre>

<pre><code class="java TropicalGardener.java">/**
 *  具体工厂类  生产热带水果、蔬菜
 */
public class TropicalGardener implements Gardener
{
    /**
     * 水果的工厂方法
     */
    public Fruit createFruit(String name)
    {
        return new TropicalFruit(name);
    }

    /**
     * 蔬菜的工厂方法
     */
    public Veggie createVeggie(String name)
    {
        return new TropicalVeggie(name);
    }
}
</code></pre>

<pre><code class="java Veggie.java">//抽象产品角色 蔬菜
public interface Veggie//标识接口
{}
</code></pre>

<pre><code class="java NorthernVeggie.java">/**
 *  具体产品类 
 */
public class NorthernVeggie implements Veggie
{
    private String name;

    public NorthernVeggie(String name)
    {
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}
</code></pre>

<pre><code class="java TropicalVeggie.java">/**
 *  具体产品类 
 */
public class TropicalVeggie implements Veggie
{
    private String name;

    public TropicalVeggie(String name)
    {
        this.name = name;
    }
    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}
</code></pre>

<pre><code class="java test.java">public class test
{
    public static void main(String[] args)
    {

    }
}
</code></pre>

<p>抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象。<br></p>

<p>可分三段理解它<br></p>

<p>第一段<br>
  一个系统需要消费多个抽象产品角色,这些抽象产品角色可以用Java接口或抽象Java类实现。既然客户端需要这些抽象产品角色的实例，为什么不使用一个工厂类负责创建这些角色的实力呢?工厂类负责创建抽象产品的实例描述如下图:<br></p>

<p>  <img src="/images/factory9.jpg"></p>

<p>但是，正如上面所指出，这些抽象产品角色是由Java接口或抽象Java类实现的，而一个Java接口或抽象
Java类是不能实例化的。也就是说，上面的设计不能成立.<br></p>

<p>第二段<br>
    根据里氏代换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色系统的一些实例，而不是这些 抽象产品的实例。换言之，也  <br/>
就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例如下图:<br></p>

<p>  <img src="/images/factory10.jpg"></p>

<p>  这是抽象工厂模式用意的基本含义。<br></p>

<p>  <img src="/images/factory11.jpg"></p>

<p>  <font color=#FF0000>&ldquo;抽象"来自"抽象产品角色&rdquo;,而"抽象工厂"就是抽象产品角色的工厂.</font><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式之装饰器模式]]></title>
    <link href="http://www.regenthypo.com/blog/2016/04/22/decorator/"/>
    <updated>2016-04-22T19:10:35+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/04/22/decorator</id>
    <content type="html"><![CDATA[<p>//TODO</p>

<h2>1.意图<br></h2>

<p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活.<br></p>
]]></content>
  </entry>
  
</feed>
