<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | regenthypo's Blog]]></title>
  <link href="http://www.regenthypo.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://www.regenthypo.com/"/>
  <updated>2016-07-06T16:08:42+08:00</updated>
  <id>http://www.regenthypo.com/</id>
  <author>
    <name><![CDATA[regenthypo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之访问者模式[7]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/06/visitor-design-pattern/"/>
    <updated>2016-07-06T10:12:31+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/06/visitor-design-pattern</id>
    <content type="html"><![CDATA[<p><font color=#FF0000><strong>[行为模式]</strong></font></p>

<p>意图:表示一个作用于<font color=#FF0000><strong>某对象结构中的各元素</strong></font>的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作.<br></p>

<p><img src="/images/visitordp1.jpg"></p>

<p>结构:<br>
<img src="/images/visitordp2.jpg"></p>

<pre><code class="java Visitor.java">/**
 *  抽象访问者
 */
public interface Visitor
{
    //对应于NodeA的访问操作
    void visit(NodeA node);

    //对应于NodeB的访问操作
    void visit(NodeB node);
}
</code></pre>

<pre><code class="java VisitorA.java">/**
 *  具体访问者 
 */
public class VisitorA implements Visitor
{
    //对应于NodeA的访问操作
    @Override
    public void visit(NodeA node)
    {
        System.out.println(node.operationA());
    }

    //对应于NodeB的访问操作
    @Override
    public void visit(NodeB node)
    {
        System.out.println(node.operationB());
    }
}
</code></pre>

<pre><code class="java VisitorB.java">/**
 *  具体访问者 
 */
public class VisitorB implements Visitor
{
    //对应于NodeA的访问操作
    @Override
    public void visit(NodeA node)
    {
        System.out.println(node.operationA());
    }

    //对应于NodeB的访问操作
    @Override
    public void visit(NodeB node)
    {
        System.out.println(node.operationB());
    }
}
</code></pre>

<pre><code class="java Node.java">/**
 *  抽象结点角色 
 */
public abstract class Node
{
    //接受操作
    public abstract void accept(Visitor visitor);
}
</code></pre>

<pre><code class="java NodeA.java">/**
 *  具体结点 
 */
public class NodeA extends Node
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public String operationA()
    {
        return "NodeA is visited";
    }
}
</code></pre>

<pre><code class="java NodeB.java">/**
 *  具体结点 
 */
public class NodeB extends Node
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public String operationB()
    {
        return "NodeB is visited";
    }
}
</code></pre>

<pre><code class="java ObjectStructure.java">/**
 *  结构对象角色 
 */
public class ObjectStructure
{
    private List&lt;Node&gt; nodes;
    private Node node;

    public ObjectStructure()
    {
        nodes = new ArrayList&lt;Node&gt;();
    }

    //执行访问操作
    public void action(Visitor visitor)
    {
        for(Node node : nodes)
        {
            node.accept(visitor);
        }
    }

    //增加新的元素
    public void add(Node node)  
    {
        nodes.add(node);
    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    private static ObjectStructure objectstru;
    private static Visitor visitor;

    public static void main(String[] args)
    {
        //创建一个结构对象
        objectstru = new ObjectStructure();

        //给结构增加一个节点
        objectstru.add(new NodeA());
        //给结构增加一个节点
        objectstru.add(new NodeB());

        //创建一个新的访问者
        visitor = new VisitorA();
        //让访问者访问结构
        objectstru.action(visitor);
    }
}
</code></pre>

<p><img src="/images/visitordp3.jpg"></p>

<p>访问者模式优点<br>
<img src="/images/visitordp4.jpg"></p>

<p>访问者模式缺点<br>
<img src="/images/visitordp5.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之中介者模式[6]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/05/mediator-design-pattern/"/>
    <updated>2016-07-05T15:41:38+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/05/mediator-design-pattern</id>
    <content type="html"><![CDATA[<p>[行为模式]</p>

<p>意图:用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且
可以独立地改变它们之间的交互.<br></p>

<p><img src="/images/mediatordp1.jpg"></p>

<p><img src="/images/mediatordp2.jpg"></p>

<p><img src="/images/mediatordp3.jpg"></p>

<pre><code class="java Mediator.java">/**
 *  抽象中介者角色 
 */
public abstract class Mediator
{
    //事件方法,由子类实现
    public abstract void colleagueChanged(Colleague c);
}
</code></pre>

<pre><code class="java ConcreteMediator.java">/**
 *  具体中介者角色 
 */
public class ConcreteMediator extends Mediator
{
    //具体中介者知道所有的具体同事类
    private Colleague1 colleague1;
    private Colleague2 colleague2;

    //事件方法的具体实现
    @Override
    public void colleagueChanged(Colleague c)
    {
        colleague1.action();
        colleague2.action();
    }

    //工厂方法,创建同事对象
    public void createConcreteMediator()
    {
        colleague1 = new Colleague1(this);
        colleague2 = new Colleague2(this);
    }

    //取值方法,提供同事对象 
    public Colleague1 getColleague1()
    {
        return colleague1;
    }

    //取值方法,提供同事对象 
    public Colleague2 getColleague2()
    {
        return colleague2;
    }
}
</code></pre>

<pre><code class="java Colleague.java">/**
 *  抽象同事类 
 */
public abstract class Colleague
{
    private Mediator mediator;

    public Colleague(Mediator mediator)
    {
        this.mediator = mediator;
    }

    //取值方法,提供中介者对象
    public Mediator getMediator()
    {
        return mediator;
    }

    //行动方法,有子类实现
    public abstract void action();

    //示意性的商业方法,调用此方法可以改变对象的内部状态
    public void change()
    {
        mediator.colleagueChanged(this);
    }
}
</code></pre>

<pre><code class="java Colleague1.java">/**
 *  具体同事类 
 *  每一个同事对象都仅知道中介者,而不知道其他的同事对象
 */
public class Colleague1 extends Colleague
{
    public Colleague1(Mediator mediator)
    {
        super(mediator);
    }

    //行动方法的具体实现
    @Override
    public void action()
    {
        System.out.println("action from colleague1");
    }
}
</code></pre>

<pre><code class="java Colleague2.java">/**
 *  具体同事类 
 *  每一个同事对象都仅知道中介者,而不知道其他的同事对象
 */
public class Colleague2 extends Colleague
{
    public Colleague2(Mediator mediator)
    {
        super(mediator);
    }

    //行动方法的具体实现
    @Override
    public void action()
    {
        System.out.println("action from colleague2");
    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        ConcreteMediator mediator = new ConcreteMediator();

        mediator.createConcreteMediator();

        Colleague1 c1 = new Colleague1(mediator);
        Colleague2 c2 = new Colleague2(mediator);

        mediator.colleagueChanged(c1);
    }
}
</code></pre>

<p><img src="/images/mediatordp4.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之策略模式[5]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/05/strategy-design-pattern/"/>
    <updated>2016-07-05T14:39:38+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/05/strategy-design-pattern</id>
    <content type="html"><![CDATA[<p>[行为模式]</p>

<p>意图:定义一系列的算法,将每一个算法封装到具有共同接口的独立的类中,从而使得他们可以相互替换.本模式可以使得算法可以独立于使用它的客户而变化.<br></p>

<p>策略模式把行为和环境分割开来。环境类负责维护和查询行为类，各种算法则在具体策略类中提供。由于算法和环境独立开来，
算法的增减、修改都不会影响环境和客户端。<br></p>

<p><img src="/images/strategydp1.jpg"></p>

<p><img src="/images/strategydp2.jpg"></p>

<pre><code class="java Context.java">/**
 *  环境角色 
 */
public class Context
{
    private Strategy strategy;

    public Strategy getStrategy()
    {
        return strategy;
    }

    public void setStrategy(Strategy strategy)
    {
        this.strategy = strategy;
    }

    //策略方法
    public void operation()
    {
        strategy.action();
    }
}
</code></pre>

<pre><code class="java Strategy.java">/**
 *  抽象策略角色 
 */
public abstract class Strategy
{
    //策略方法
    public abstract void action();//具体策略类要实现的共同接口
}
</code></pre>

<pre><code class="java ConcreteStrategy1.java">/**
 *  具体策略角色 
 */
public class ConcreteStrategy1 extends Strategy
{
    @Override
    public void action()//策略方法
    {
        //实现算法
        System.out.println("strategy1 operation.");
    }
}
</code></pre>

<pre><code class="java ConcreteStrategy2.java">/**
 *  具体策略角色 
 */
public class ConcreteStrategy2 extends Strategy
{
    @Override
    public void action()
    {
        //实现算法
        System.out.println("strategy2 operation.");
    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        Context context = new Context();

        context.setStrategy(new ConcreteStrategy1());
        context.operation();

        context.setStrategy(new ConcreteStrategy2());
        context.operation();
    }
}
</code></pre>

<p><img src="/images/strategydp3.jpg"></p>

<p><img src="/images/strategydp4.jpg"></p>

<p><img src="/images/strategydp5.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之命令模式[4]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/04/command-design-pattern/"/>
    <updated>2016-07-04T16:04:36+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/04/command-design-pattern</id>
    <content type="html"><![CDATA[<p>[行为模式]</p>

<p>意图:命令模式将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可撤销的操作.</p>

<p>命令模式是对命令的封装.命令模式把发出命令的责任和执行命令的责任分隔开,委派给不同的对象.<br>
每一个命令都是一个操作:请求的一方发出请求要求执行一个操作;接受的一方收到请求,并执行操作.<br>
命令模式允许请求的一方和接受的一方独立开来,使得请求的一方不必知道接受请求的一方的接口,更不必知道请求是怎么被接受,
以及操作是否被执行、何时被执行、以及怎么被执行的。<br></p>

<p>命令允许请求的一方和接受请求的一方能够独立演化,从而具有以下优点:<br>
1. 命令模式使新的命名很容易地被加入到系统里。
2. 允许接受请求的一方决定是否要否决请求。
3. 较容易地设计一个命令队列。
4. 可以容易地实现对请求的Undo和Redo.
5. 在需要的情况下，可以较容易地将命令记入日志.</p>

<p><img src="/images/commanddp1.jpg"></p>

<pre><code class="java Command.java">/**
 *  命名角色 
 */
public interface Command
{
    void execute();
}
</code></pre>

<pre><code class="java ConcreteCommand.java">/**
 *  具体命令角色 
 */
public class ConcreteCommand implements Command
{
    private Receiver receiver;

    public ConcreteCommand(Receiver receiver)
    {
        this.receiver = receiver;
    }

    @Override
    public void execute()//执行方法
    {
        receiver.action();
    }
}
</code></pre>

<pre><code class="java Invoker.java">/**
 *  请求者角色 
 */
public class Invoker
{
    private Command command;

    public Invoker(Command command)
    {
        this.command = command;
    }

    //行动方法
    public void action()
    {
        command.execute();
    }
}
</code></pre>

<pre><code class="java Receiver.java">/**
 *  接受者角色 
 */
public class Receiver
{
    public Receiver()
    {
    }

    //行动方法
    public void action()
    {
        System.out.println("action has been taken!");
    }
}
</code></pre>

<pre><code class="java Client.java">/**
 *  客户角色 
 */
public class Client
{
    public static void main(String[] args)
    {
        //接受者
        Receiver receiver = new Receiver();

        //命令 确定要发送给接受者的命令
        Command command = new ConcreteCommand(receiver);

        //请求者 调用命令对象执行请求
        Invoker invoker = new Invoker(command);

        invoker.action();
    }
}
</code></pre>

<p>在什么情况下应当使用命令模式<br>
<img src="/images/commanddp2.jpg"></p>

<p>命令模式的优缺点<br>
<img src="/images/commanddp3.jpg"></p>

<p>Java语言内应用实例<br>
<img src="/images/commanddp4.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之组合模式[3]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/04/composite-design-pattern/"/>
    <updated>2016-07-04T13:27:47+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/04/composite-design-pattern</id>
    <content type="html"><![CDATA[<p>[结构型模式]</p>

<p>意图:将对象组合成树形结构以表示"部分-整体"的层次结构,组合模式使得用户对单个对象和组合对象的使用具有一致性.<br>
    &ndash;关键是单个对象和组合对象都间接或直接实现了最顶层的抽象类或接口，所以对它们的操作具有一致性.<br></p>

<p>安全式的组合模式的结构</p>

<p><img src="/images/cdp1.jpg"></p>

<p>透明式的组合模式的结构</p>

<p><img src="/images/cdp2.jpg"></p>

<p>安全式的组合模式</p>

<p><img src="/images/cdp5.jpg"></p>

<pre><code class="java Component.java">/**
 *  抽象构件角色
 *  抽象构件角色并不定义管理子对象的方法.
 */
public interface Component
{

    Component getComponent();

    void sampleOperation();
}
</code></pre>

<pre><code class="java Composite.java">/**
 *  树枝构件角色 
 */
public class Composite implements Component
{
    //树枝构件包含的下级子对象的集合(包含树枝构件和树叶构件)
    private List&lt;Component&gt; list = new ArrayList();

    @Override
    public Composite getComposite()
    {
        return this;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Composite operation");

        for(Component component : list)
        {
            component.sampleOperation();
        }
    }

    //增加子构件对象
    public void add(Component component)
    {
        list.add(component);
    }

    //删除子构件对象
    public void remove(Component component)
    {
        list.remove(component);
    }
}
</code></pre>

<pre><code class="java Leaf.java">/**
 *  树叶构件 
 */
public class Leaf implements Component
{
    @Override
    public Composite getComposite()
    {
        return null;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Leaf operation");
    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        Component leaf1 = new Leaf();
        Component leaf2 = new Leaf();

        Component composite = new Composite();
        composite.getComposite().add(leaf1);
        composite.getComposite().add(leaf2);
        composite.getComposite().sampleOperation();
    }
}
</code></pre>

<p>执行结果:<br>
<img src="/images/cdp4.jpg"></p>

<p>透明式的组合模式</p>

<p><img src="/images/cdp6.jpg"></p>

<pre><code class="java Component.java">/**
 *  抽象构件角色 
 *  抽象构件角色定义了管理子对象的方法.
 */
public interface Component
{

    public void sampleOperation();

    public void add(Component component);

    public void remove(Component component);

    public Component getComponent();
}
</code></pre>

<pre><code class="java Composite.java">/**
 *  树枝构件角色 
 *
 */
public class Composite implements Component
{
    private List&lt;Component&gt; list = new ArrayList();

    @Override
    public Component getComponent()
    {
        return this;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Composite operation");

        for(Component component : list)
        {
            component.getComponent().sampleOperation();
        }
    }

    @Override
    public void add(Component component)
    {
        list.add(component);
    }

    @Override
    public void remove(Component component)
    {
        list.remove(component);
    }
}
</code></pre>

<pre><code class="java Leaf.java">/**
 *  树叶构件角色
 *  树叶构件角色也实现了抽象构件角色所声明的各个方法,包括管理集合的方法
 *  但是树叶构件因为没有子结点,因此并没有集合可以用来管理.
 */
public class Leaf implements Component
{
    @Override
    public Component getComponent()
    {
        return this;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Leaf operation");
    }

    @Override
    public void add(Component component)
    {
        // TODO Auto-generated method stub

    }

    @Override
    public void remove(Component component)
    {
        // TODO Auto-generated method stub

    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        Component leaf1 = new Leaf();
        Component leaf2 = new Leaf();
        Component leaf3 = new Leaf();
        Component composite = new Composite();
        Component composite1 = new Composite();

        composite1.add(leaf3);

        composite.getComponent().add(leaf1);
        composite.getComponent().add(leaf2);
        composite.getComponent().add(composite1);

        composite.getComponent().sampleOperation();
    }
}
</code></pre>

<p>运行结果:<br>
<img src="/images/cdp8.jpg"></p>

<p>本例的结构<br>
<img src="/images/cdp7.jpg"></p>

<p>应用实例</p>

<p>由于AWT和Swing的图形界面构件是构建在AWT库中的Container类和Component类上的,从下面的AWT组合模式式类图可以看出，
Button和CheckBox是树叶型的构件,而Container则是树枝型的构件.</p>

<p><img src="/images/cdp3.jpg"></p>
]]></content>
  </entry>
  
</feed>
