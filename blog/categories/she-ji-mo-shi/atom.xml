<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | regenthypo's Blog]]></title>
  <link href="http://www.regenthypo.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://www.regenthypo.com/"/>
  <updated>2016-07-25T16:40:24+08:00</updated>
  <id>http://www.regenthypo.com/</id>
  <author>
    <name><![CDATA[regenthypo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之备忘录模式[18]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/22/memento-design-pattern/"/>
    <updated>2016-07-22T16:42:01+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/22/memento-design-pattern</id>
    <content type="html"><![CDATA[<p><font color=#FF0000><strong>[行为模式]</strong></font></p>

<p><font color=#FF0000><strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</strong></font></p>

<p><font color=#FF0000><strong>别名:Token</strong></font></p>

<p><strong>备忘录模式结构</strong><br>
{%img /images/mementodp1.jpg %}</p>

<p><strong>备忘录模式角色</strong><br>
{%img /images/mementodp2.jpg %}</p>

<p><strong>备忘录模式代码</strong></p>

<p><strong>发起人</strong><br>
```java
/<em>*
 *  发起人角色
 *  发起人角色利用一个新创建的备忘录对象将自己内部状态存储起来
 </em>/
public class Originator
{
    private String state;</p>

<pre><code>/**
 *  工厂方法 , 返回一个新的备忘录对象 
 */
public Memento createMemento()
{
    //由发起人新建备忘录对象，并将自己的状态存储在备忘录对象中
    return new Memento(state);
}

/**
 *  将发起人恢复到备忘录对象所记载的状态 
 */
public void restoreMemento(Memento memento)
{
    this.state = memento.getState();
}

/**
 *  状态的取值方法 
 */
public String getState()
{
    return this.state;
}

/**
 *  状态的赋值方法 
 *  设定发起人对象的内部状态
 */
public void setState(String state)
{
    this.state = state;
    System.out.println("CurrentState = " + this.state);
}
</code></pre>

<p>}
```</p>

<p><strong>备忘录</strong><br>
```java
/<em>*
 *  备忘录角色
 *  备忘录对象将发起人对象传入的状态存储起来
 </em>/
public class Memento
{
    private String state;</p>

<pre><code>public Memento(String state)
{
    this.state = state;
}

/**
 *  状态的取值方法 
 */
public String getState()
{
    return this.state;
}

/**
 *  状态的赋值方法 
 */
public void setState(String state)
{
    this.state = state;
}
</code></pre>

<p>}</p>

<pre><code>
**负责人**&lt;br&gt;
</code></pre>

<p>/<em>*
 *  负责人角色
 *  负责人角色负责保存备忘录对象，但从不修改(甚至不查看)备忘录对象的内容
 </em>/
public class Caretaker
{
    //负责人持有备忘录对象的引用.
    private Memento memento;</p>

<pre><code>/**
 *  备忘录的取值方法 
 */
public Memento retrieveMemento()
{
    return this.memento;
}

/**
 *  备忘录的赋值方法 
 */
public void saveMemento(Memento memento)
{
    this.memento = memento;
}
</code></pre>

<p>}
```</p>

<p><strong>测试</strong><br>
```java
/<em>*
 *  客户端角色
 </em>/
public class Client
{
    private static Originator o = new Originator();//发起人
    private static Caretaker c = new Caretaker();//负责人</p>

<pre><code>public static void main(String[] args)
{
    //改变负责人的状态
    o.setState("on");
    System.out.println(o.getState());

    //创建备忘录对象，并将发起人对象的状态存储起来
    c.saveMemento(o.createMemento());

    //改变负责人的状态
    o.setState("off");

    System.out.println(o.getState());
    //恢复发起人对象的状态
    o.restoreMemento(c.retrieveMemento());
    System.out.println(o.getState());
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之代理模式[17]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/21/proxy-design-pattern/"/>
    <updated>2016-07-21T15:24:50+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/21/proxy-design-pattern</id>
    <content type="html"><![CDATA[<h2>静态代理</h2>

<p><font color=#FF0000><strong>[结构型模式]</strong></font></p>

<p><font color=#FF0000><strong>为其他对象提供一种代理以控制对这个对象的访问.</strong></font></p>

<p><strong>代理模式结构</strong><br>
{%img /images/proxydp1.jpg %}</p>

<p><strong>代理模式角色</strong><br>
{%img /images/proxydp2.jpg %}</p>

<p><strong>代理模式代码</strong></p>

<p><strong>抽象主题</strong>
<code>java
/**
 *  抽象主题角色
 */
public abstract class Subject
{
    public abstract void request();
}
</code></p>

<p><strong>真实主题</strong>
<code>java
/**
 *  真实主题角色
 */
public class RealSubject extends Subject
{
    @Override
    public void request()
    {
        System.out.println("from real subject");
    }
}
</code></p>

<p><strong>代理主题</strong>
```java
/<em>*
 *  代理主题角色
 </em>/
public class ProxySubject extends Subject
{
    //代理对象含有RealSubject对象的引用
    private RealSubject realsubject;</p>

<pre><code>/**
 *  请求前操作 
 */
private void preRequest()
{
    System.out.println("prerequest!");
}

/**
 *  请求后操作 
 */
private void postRequest()
{
    System.out.println("postrequest");
}

/**
 * 实现请求方法
 */
@Override
public void request()
{
    preRequest();//可插入业务代码

    if(realsubject == null)
    {
        realsubject = new RealSubject();
    }

    realsubject.request();

    postRequest();//可插入业务代码
}
</code></pre>

<p>}
```</p>

<p><strong>测试</strong>
```java
public class test
{
    public static void main(String[] args)
    {
        Subject subject = new ProxySubject();</p>

<pre><code>    subject.request();
}
</code></pre>

<p>}
```</p>

<h2>动态代理</h2>

<p>//TODO</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之状态模式[16]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/21/state-design-pattern/"/>
    <updated>2016-07-21T14:31:13+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/21/state-design-pattern</id>
    <content type="html"><![CDATA[<p><font color=#FF0000><strong>[行为模式]</strong></font></p>

<p><font color=#FF0000><strong>允许一个对象在其内部状态改变时改变它的行为,看起来似乎修改了它的类.</strong></font></p>

<p><font color=#FF0000><strong>别名:状态对象(Objects for States)</strong></font></p>

<p><strong>状态模式结构</strong><br>
{%img /images/statedp1.jpg %}</p>

<p><strong>状态模式角色</strong><br>
{%img /images/statedp2.jpg %}</p>

<p><strong>状态模式代码</strong></p>

<p><strong>抽象状态</strong><br>
<code>java
/**
 *  抽象状态角色
 */
public interface State
{
    //定义与Context一个特定状态相关的行为
    public void operation();
}
</code></p>

<p><strong>具体状态</strong><br>
<code>java
/**
 *  具体状态角色
 */
public class ConcreteState1 implements State
{
    @Override
    public void operation()
    {
        System.out.println("state1 operation!");
    }
}
</code></p>

<p><strong>具体状态</strong><br>
<code>java
/**
 *  具体状态角色
 */
public class ConcreteState2 implements State
{
    @Override
    public void operation()
    {
        System.out.println("state2 operation!");
    }
}
</code></p>

<p><strong>具体状态</strong><br>
```java
/<em>*
 *  具体状态角色
 </em>/
public class ConcreteState3 implements State
{
    @Override
    public void operation()
    {
        System.out.println(&ldquo;state3 operation!&rdquo;);
    }
}</p>

<pre><code>
**环境**&lt;br&gt;
</code></pre>

<p>/<em>*
 *  环境角色
 </em>/
public class Context
{
    //环境类持有一个具体状态类的实例
    private State state;</p>

<pre><code>//环境类与状态类之间是聚合关系
public void setState(State state)
{
    this.state = state;
}

public void operation()
{
    //当持有的具体状态类不同时,该操作产生不同的行为
    state.operation();
}
</code></pre>

<p>}
```</p>

<p><strong>客户端</strong><br>
```java
public class Client
{
    public static void main(String[] args)
    {
        Context context = new Context();//环境类</p>

<pre><code>    ConcreteState1 state1 = new ConcreteState1();//具体状态1
    ConcreteState2 state2 = new ConcreteState2();//具体状态2
    ConcreteState3 state3 = new ConcreteState3();//具体状态3

    context.setState(state1);//设定环境状态
    context.operation();

    System.out.println("------------------------------");

    context.setState(state2);//设定环境状态
    context.operation();

    System.out.println("------------------------------");

    context.setState(state3);//设定环境状态
    context.operation();

    System.out.println("------------------------------");
}
</code></pre>

<p>}
```</p>

<p><strong>运行结果</strong><br>
{%img /images/statedp3.jpg %}</p>

<p><strong>状态模式适用情况</strong><br>
{%img /images/statedp4.jpg %}</p>

<p><strong>状态模式效果</strong><br>
{%img /images/statedp5.jpg %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之观察者模式[15]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/21/observer-design-pattern/"/>
    <updated>2016-07-21T12:58:41+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/21/observer-design-pattern</id>
    <content type="html"><![CDATA[<p><font color=#FF0000><strong>[行为模式]</strong></font></p>

<p><font color=#FF0000><strong>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新.</strong></font></p>

<p><font color=#FF0000><strong>别名:依赖(Dependents),发布-订阅(Publish-Subscribe)</strong></font></p>

<p>{%img /images/observerdp0.jpg %}</p>

<p><strong>观察者模式结构</strong><br>
{%img /images/observerdp1.jpg %}</p>

<p><strong>观察者模式角色</strong><br>
{%img /images/observerdp2.jpg %}</p>

<p><strong>观察者模式代码</strong></p>

<p><strong>抽象观察者</strong><br>
<code>java
/**
 *  抽象观察者角色.
 */
public interface Observer
{
    /**
     *  调用这个方法会更新自己.
     */
    void update();
}
</code></p>

<p><strong>具体观察者</strong><br>
<code>java
/**
 *  具体观察者角色.
 */
public class ConcreteObserver implements Observer
{
    /**
     *  调用这个方法会更新自己.
     */
    @Override
    public void update()
    {
        System.out.println("I'm notified!");
    }
}
</code></p>

<p><strong>抽象目标</strong><br>
```java
/<strong>
 *  抽象主题角色
 */
public interface Subject
{
    /</strong>
     *  调用这个方法登记一个新的观察者对象
     */
    public void attach(Observer observer);</p>

<pre><code>/**
 *  调用这个方法删除一个已登记的观察者对象 
 */
public void detach(Observer observer);

/**
 *  调用这个方法通知所有已登记的观察者. 
 */
public void notifyObservers();
</code></pre>

<p>}
```</p>

<p><strong>具体目标</strong><br>
```java
/<em>*
 *  具体主题角色.
 </em>/
public class ConcreteSubject implements Subject
{
    private ArrayList<Observer> observers = new ArrayList<Observer>();</p>

<pre><code>/**
 *  调用这个方法登记一个新的观察者对象
 */
@Override
public void attach(Observer observer)
{
    observers.add(observer);
}

/**
 *  调用这个方法删除一个已登记的观察者对象 
 */
@Override
public void detach(Observer observer)
{
    observers.remove(observer);
}

/**
 *  调用这个方法通知所有已登记的观察者. 
 */
@Override
public void notifyObservers()
{
    Iterator&lt;Observer&gt; iterator = observers.iterator();

    while(iterator.hasNext())
    {
        iterator.next().update();
    }

}
</code></pre>

<p>}
```</p>

<p><strong>测试</strong><br>
```java
public class test
{</p>

<pre><code>public static void main(String[] args)
{
    Observer o1 = new ConcreteObserver();//观察者
    Observer o2 = new ConcreteObserver();//观察者
    Observer o3 = new ConcreteObserver();//观察者

    Subject s1 = new ConcreteSubject();//目标

    s1.attach(o1);
    s1.attach(o2);
    s1.attach(o3);

    s1.notifyObservers();

    System.out.println("--------------------------");

    s1.detach(o3);
    s1.notifyObservers();

    System.out.println("--------------------------");
}
</code></pre>

<p>}
```</p>

<p><strong>运行结果</strong><br>
{%img /images/observerdp3.jpg %}</p>

<p><strong>观察者模式优缺点</strong><br>
{%img /images/observerdp4.jpg %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之装饰模式[14]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/20/decorator-design-pattern/"/>
    <updated>2016-07-20T21:01:14+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/20/decorator-design-pattern</id>
    <content type="html"><![CDATA[<p><font color=#FF0000><strong>[结构型模式]</strong></font></p>

<p><font color=#FF0000><strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活.</strong></font></p>

<p><font color=#FF0000><strong>别名:包装器 Wrapper</strong></font></p>

<p><strong>装饰模式结构</strong><br>
{%img /images/decoratordp1.jpg %}</p>

<p><strong>装饰模式的角色</strong><br>
{%img /images/decoratordp2.jpg %}</p>

<p><strong>装饰模式代码</strong></p>

<p><strong>抽象组件</strong><br>
<code>java
/**
 *  抽象构件角色
 */
public interface Component
{
    public void sampleOperation();
}
</code></p>

<p><strong>具体组件</strong><br>
<code>java
/**
 *  具体构件角色
 *  可以给具体组件上添加各种装饰
 */
public class ConcreteComponent implements Component
{   
    @Override
    public void sampleOperation()
    {
        System.out.println("具体组件");
    }
}
</code></p>

<p><strong>装饰角色</strong><br>
```java
/<em>*
 *  装饰角色
 *
 *  装饰角色类实现组件接口,与具体组件类之间是聚合关系.
 </em>/
public class Decorator implements Component
{
    private Component component;</p>

<pre><code>//装饰角色类和组件类之间是聚合关系
//有参构造函数
public Decorator(Component component)
{
    this.component = component;
}

//无参构造函数
public Decorator()
{
}

//实现抽象组件的方法
@Override
public void sampleOperation()
{
    component.sampleOperation();
}
</code></pre>

<p>}
```</p>

<p><strong>具体装饰A</strong><br>
```java
/<em>*
 *  具体装饰角色
 </em>/
public class ConcreteDecoratorA extends Decorator
{
    //与组件之间是聚合关系
    public ConcreteDecoratorA(Component component)
    {
        super(component);
    }</p>

<pre><code>@Override
public void sampleOperation()
{
    super.sampleOperation();

    System.out.println("给组件添加装饰A");
}
</code></pre>

<p>}
```</p>

<p><strong>具体装饰B</strong><br>
```java
/<em>*
 *  具体装饰角色
 </em>/
public class ConcreteDecoratorB extends Decorator
{
    //与组件之间是聚合关系
    public ConcreteDecoratorB(Component component)
    {
        super(component);
    }</p>

<pre><code>@Override
public void sampleOperation()
{
    super.sampleOperation();

    System.out.println("给组件添加装饰B");
}
</code></pre>

<p>}
```</p>

<p><strong>测试类</strong><br>
```java
public class mytest
{
    private final static Component c = new ConcreteComponent();//没有装饰的组件</p>

<pre><code>private final static Component d = new ConcreteDecoratorA(c);//添加了一个装饰A的组件

private final static Component e = new ConcreteDecoratorB(d);//添加了装饰A和装饰B的组件

public static void main(String[] args)
{
    c.sampleOperation();

    System.out.println("---------------------");

    d.sampleOperation();

    System.out.println("---------------------");

    e.sampleOperation();

    System.out.println("---------------------");

    Component f = new ConcreteDecoratorB(new ConcreteDecoratorA(new ConcreteComponent()));

    f.sampleOperation();

    System.out.println("---------------------");
}
</code></pre>

<p>}
```</p>

<p><strong>运行结果</strong><br>
{%img /images/decoratordp3.jpg %}</p>

<p><strong>装饰模式优点</strong><br>
{%img /images/decoratordp4.jpg %}</p>

<p><strong>装饰模式缺点</strong><br>
{%img /images/decoratordp5.jpg %}</p>
]]></content>
  </entry>
  
</feed>
