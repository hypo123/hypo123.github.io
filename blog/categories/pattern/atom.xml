<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Pattern | regenthypo's Blog]]></title>
  <link href="http://www.regenthypo.com/blog/categories/pattern/atom.xml" rel="self"/>
  <link href="http://www.regenthypo.com/"/>
  <updated>2016-07-05T16:52:56+08:00</updated>
  <id>http://www.regenthypo.com/</id>
  <author>
    <name><![CDATA[regenthypo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一天一设计模式之组合模式[3]]]></title>
    <link href="http://www.regenthypo.com/blog/2016/07/04/composite-design-pattern/"/>
    <updated>2016-07-04T13:27:47+08:00</updated>
    <id>http://www.regenthypo.com/blog/2016/07/04/composite-design-pattern</id>
    <content type="html"><![CDATA[<p>[结构型模式]</p>

<p>意图:将对象组合成树形结构以表示"部分-整体"的层次结构,组合模式使得用户对单个对象和组合对象的使用具有一致性.<br>
    &ndash;关键是单个对象和组合对象都间接或直接实现了最顶层的抽象类或接口，所以对它们的操作具有一致性.<br></p>

<p>安全式的组合模式的结构</p>

<p><img src="/images/cdp1.jpg"></p>

<p>透明式的组合模式的结构</p>

<p><img src="/images/cdp2.jpg"></p>

<p>安全式的组合模式</p>

<p><img src="/images/cdp5.jpg"></p>

<pre><code class="java Component.java">/**
 *  抽象构件角色
 *  抽象构件角色并不定义管理子对象的方法.
 */
public interface Component
{

    Component getComponent();

    void sampleOperation();
}
</code></pre>

<pre><code class="java Composite.java">/**
 *  树枝构件角色 
 */
public class Composite implements Component
{
    //树枝构件包含的下级子对象的集合(包含树枝构件和树叶构件)
    private List&lt;Component&gt; list = new ArrayList();

    @Override
    public Composite getComposite()
    {
        return this;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Composite operation");

        for(Component component : list)
        {
            component.sampleOperation();
        }
    }

    //增加子构件对象
    public void add(Component component)
    {
        list.add(component);
    }

    //删除子构件对象
    public void remove(Component component)
    {
        list.remove(component);
    }
}
</code></pre>

<pre><code class="java Leaf.java">/**
 *  树叶构件 
 */
public class Leaf implements Component
{
    @Override
    public Composite getComposite()
    {
        return null;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Leaf operation");
    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        Component leaf1 = new Leaf();
        Component leaf2 = new Leaf();

        Component composite = new Composite();
        composite.getComposite().add(leaf1);
        composite.getComposite().add(leaf2);
        composite.getComposite().sampleOperation();
    }
}
</code></pre>

<p>执行结果:<br>
<img src="/images/cdp4.jpg"></p>

<p>透明式的组合模式</p>

<p><img src="/images/cdp6.jpg"></p>

<pre><code class="java Component.java">/**
 *  抽象构件角色 
 *  抽象构件角色定义了管理子对象的方法.
 */
public interface Component
{

    public void sampleOperation();

    public void add(Component component);

    public void remove(Component component);

    public Component getComponent();
}
</code></pre>

<pre><code class="java Composite.java">/**
 *  树枝构件角色 
 *
 */
public class Composite implements Component
{
    private List&lt;Component&gt; list = new ArrayList();

    @Override
    public Component getComponent()
    {
        return this;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Composite operation");

        for(Component component : list)
        {
            component.getComponent().sampleOperation();
        }
    }

    @Override
    public void add(Component component)
    {
        list.add(component);
    }

    @Override
    public void remove(Component component)
    {
        list.remove(component);
    }
}
</code></pre>

<pre><code class="java Leaf.java">/**
 *  树叶构件角色
 *  树叶构件角色也实现了抽象构件角色所声明的各个方法,包括管理集合的方法
 *  但是树叶构件因为没有子结点,因此并没有集合可以用来管理.
 */
public class Leaf implements Component
{
    @Override
    public Component getComponent()
    {
        return this;
    }

    @Override
    public void sampleOperation()
    {
        System.out.println("Leaf operation");
    }

    @Override
    public void add(Component component)
    {
        // TODO Auto-generated method stub

    }

    @Override
    public void remove(Component component)
    {
        // TODO Auto-generated method stub

    }
}
</code></pre>

<pre><code class="java Client.java">public class Client
{
    public static void main(String[] args)
    {
        Component leaf1 = new Leaf();
        Component leaf2 = new Leaf();
        Component leaf3 = new Leaf();
        Component composite = new Composite();
        Component composite1 = new Composite();

        composite1.add(leaf3);

        composite.getComponent().add(leaf1);
        composite.getComponent().add(leaf2);
        composite.getComponent().add(composite1);

        composite.getComponent().sampleOperation();
    }
}
</code></pre>

<p>运行结果:<br>
<img src="/images/cdp8.jpg"></p>

<p>本例的结构<br>
<img src="/images/cdp7.jpg"></p>

<p>应用实例</p>

<p>由于AWT和Swing的图形界面构件是构建在AWT库中的Container类和Component类上的,从下面的AWT组合模式式类图可以看出，
Button和CheckBox是树叶型的构件,而Container则是树枝型的构件.</p>

<p><img src="/images/cdp3.jpg"></p>
]]></content>
  </entry>
  
</feed>
